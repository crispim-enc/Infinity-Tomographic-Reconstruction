
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\iPET\1_Device_creation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_iPET_1_Device_creation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_iPET_1_Device_creation.py:


iPET device creation
======================

This is an example how to create a new device. In this case a new system for EasyCT
The device should be run only one time to create a new device.  A folder with a unique identifier will be created
Afterwars the device can be read from the folder and added to the new TOR files created

# # sphinx_gallery_thumbnail_path = 'examples/EasyPETCT/easyPETCT.png'

.. GENERATED FROM PYTHON SOURCE LINES 23-24

Imports to create the device

.. GENERATED FROM PYTHON SOURCE LINES 24-36

.. code-block:: Python

    import matplotlib.pyplot as plt
    import numpy as np
    from scipy.optimize import curve_fit

    from toor.Geometry.easyPETBased import EasyCTGeometry
    # from toor.DetectionLayout.RadiationProducer import GenericRadiativeSource
    from toor.DetectionLayout.Modules import  PETModule, easyPETModule

    from toor.Designer import DeviceDesignerStandalone
    from toor.Device import StoreDeviceInFo, EnergyResolutionFunction
    # from toor.TORFilesReader import ToRFile








.. GENERATED FROM PYTHON SOURCE LINES 37-41

.. image:: ../../images/ipetmodules.png
   :alt: EasyCT Diagram
   :width: 600px
   :align: center

.. GENERATED FROM PYTHON SOURCE LINES 44-45

SYSTEM ENERGY RESPONSE FUNCTION (Not mandatory)

.. GENERATED FROM PYTHON SOURCE LINES 45-77

.. code-block:: Python

    def systemEnergyResponseFunction(E, Er, p1, p2):
        """
        Energy response function of the system
        :param energy: energy of the photon
        :param Er: energy resolution
        """
        fwhm = np.sqrt((p1 / E) ** 2 + (p2) ** 2)
        return fwhm / E


    energies = np.array([30, 59.6, 511])
    energy_resolution = np.array([0.63, 0.33, 0.14])

    fit = curve_fit(systemEnergyResponseFunction, energies, energy_resolution)
    plt.figure()
    plt.plot(energies, energy_resolution * 100, 'ro', label='Data')
    plt.plot(np.arange(25, 600, 10), systemEnergyResponseFunction(np.arange(25, 600, 10), *fit[0]) * 100, 'b-', label='Fit')
    plt.xlabel('Energy (keV)')
    plt.ylabel('Energy Resolution (%)')
    plt.legend()
    plt.savefig("../../images/system_energy_response_function.png")


    # .. image:: ../../images/system_energy_response_function.png
    #     :alt: EasyCT Diagram
    #     :width: 400px
    #     :align: center

    energy_window = [energies - energies * systemEnergyResponseFunction(energies, *fit[0]),
                     energies + energies * systemEnergyResponseFunction(energies, *fit[0])]
    systemEnergyResolution = EnergyResolutionFunction(p1=fit[0][1], p2=fit[0][2])




.. image-sg:: /auto_examples/iPET/images/sphx_glr_1_Device_creation_001.png
   :alt: 1 Device creation
   :srcset: /auto_examples/iPET/images/sphx_glr_1_Device_creation_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    C:\Users\pedro\OneDrive\Documentos\GitHub\Infinity-Tomographic-Reconstruction\docs\source\examples\iPET\1_Device_creation.py:58: OptimizeWarning: Covariance of the parameters could not be estimated
      fit = curve_fit(systemEnergyResponseFunction, energies, energy_resolution)




.. GENERATED FROM PYTHON SOURCE LINES 78-81

Setup the type of the detector module. You should not call the PETModule class directly.
This object  should entry as  argument in the geometry class type for proper setting. This allows to set multiple
cells. Number of modules, rotations and translations are set after the geometry class is created.

.. GENERATED FROM PYTHON SOURCE LINES 81-87

.. code-block:: Python

    _module = PETModule
    # _module = easyPETModule











.. GENERATED FROM PYTHON SOURCE LINES 88-92

The next step  is to choose the geometry type, which is `EasyCTGeometry` in this case. This function is inherited
from the DualRotationGeometry class which is an Device Object. Here we set the distance between the two points of rotation,
the distance between the fan motor and the detector modules (closest side) and the distance between the fan motor and the detector modules (far side).
as well as the initial position of the x-ray source.

.. GENERATED FROM PYTHON SOURCE LINES 92-105

.. code-block:: Python


    newDevice = EasyCTGeometry(detector_moduleA=_module, detector_moduleB=_module)
    newDevice.setDeviceName("iPET")
    newDevice.setDeviceType("PET")
    newDevice.setEnergyResolutionFunction(systemEnergyResolution)  # use to apply energy cuts
    newDevice.setDistanceBetweenMotors(65)  # Distance between the two points of rotation
    newDevice.setDistanceFanMotorToDetectorModulesOnSideA(
        0)  # Distance between the fan motor and the detector modules (closest side)
    newDevice.setDistanceFanMotorToDetectorModulesOnSideB(
        130)  # Distance between the fan motor and the detector modules (far side)
    # newDevice.xRayProducer.setFocalSpotInitialPositionWKSystem([12.55, 3, 0])
    # newDevice.evaluateInitialSourcePosition()  # evaluate the initial position of the source








.. GENERATED FROM PYTHON SOURCE LINES 106-113

Set modules Side A. For each module, should be in the list  the equivalent rotation and translation variables.
If for example two modules are set, the variables should be in the list as follows:
  moduleSideA_X_translation = np.array([15, 20], dtype=np.float32)
  moduleSideA_Y_translation = np.array([0, 0], dtype=np.float32)

  ...
Very important. The translations are regarding the fan motor center. The rotations are regarding the center of the module.

.. GENERATED FROM PYTHON SOURCE LINES 113-132

.. code-block:: Python

    newDevice.setNumberOfDetectorModulesSideA(4)

    moduleSideA_X_translation = np.array([10,10,10,10], dtype=np.float32)
    moduleSideA_Y_translation = np.array([0,0, 0, 0], dtype=np.float32)
    moduleSideA_Z_translation = np.arange(0,16*1.6*4+3,16*1.6+1)
    moduleSideA_alpha_rotation = np.array([0,0,0,0], dtype=np.float32)
    moduleSideA_beta_rotation = np.array([0, 0, 0, 0 ], dtype=np.float32)
    moduleSideA_sigma_rotation = np.array([0,0,0,0], dtype=np.float32)

    for i in range(newDevice.numberOfDetectorModulesSideA):
        # newDevice.detectorModulesSideA[i].model32()
        # newDevice.detectorModulesSideA[i].model16_2()
        newDevice.detectorModulesSideA[i].setXTranslation(moduleSideA_X_translation[i])
        newDevice.detectorModulesSideA[i].setYTranslation(moduleSideA_Y_translation[i])
        newDevice.detectorModulesSideA[i].setZTranslation(moduleSideA_Z_translation[i])
        newDevice.detectorModulesSideA[i].setAlphaRotation(moduleSideA_alpha_rotation[i])
        newDevice.detectorModulesSideA[i].setBetaRotation(moduleSideA_beta_rotation[i])
        newDevice.detectorModulesSideA[i].setSigmaRotation(moduleSideA_sigma_rotation[i])








.. GENERATED FROM PYTHON SOURCE LINES 133-134

Set modules Side B.

.. GENERATED FROM PYTHON SOURCE LINES 134-152

.. code-block:: Python

    newDevice.setNumberOfDetectorModulesSideB(4)
    moduleSideB_X_translation = np.array([-140, -140, -140, -140], dtype=np.float32)
    moduleSideB_Y_translation = np.array([0, 0, 0,0], dtype=np.float32)
    moduleSideB_Z_translation = np.arange(0,16*1.6*4+3,16*1.6+1)
    moduleSideB_alpha_rotation = np.array([-0, -0, -0, -0 ], dtype=np.float32)
    moduleSideB_beta_rotation = np.array([0, 0, 0, 0 ], dtype=np.float32)
    moduleSideB_sigma_rotation = np.array([180,180,180,180], dtype=np.float32)

    for i in range(newDevice.numberOfDetectorModulesSideB):
        # newDevice.detectorModulesSideB[i].model32()
        # newDevice.detectorModulesSideB[i].model16_2()
        newDevice.detectorModulesSideB[i].setXTranslation(moduleSideB_X_translation[i])
        newDevice.detectorModulesSideB[i].setYTranslation(moduleSideB_Y_translation[i])
        newDevice.detectorModulesSideB[i].setZTranslation(moduleSideB_Z_translation[i])
        newDevice.detectorModulesSideB[i].setAlphaRotation(moduleSideB_alpha_rotation[i])
        newDevice.detectorModulesSideB[i].setBetaRotation(moduleSideB_beta_rotation[i])
        newDevice.detectorModulesSideB[i].setSigmaRotation(moduleSideB_sigma_rotation[i])








.. GENERATED FROM PYTHON SOURCE LINES 153-159

Set the inital coordinates of the system. In both coordinate

.. image:: ../../images/geometry_easypet_mathematical_calculation.png
   :alt: EasyCT Diagram
   :width: 600px
   :align: center

.. GENERATED FROM PYTHON SOURCE LINES 159-163

.. code-block:: Python

    newDevice.generateInitialCoordinatesWKSystem()
    # newDevice.generateInitialCoordinatesXYSystem()









.. GENERATED FROM PYTHON SOURCE LINES 164-165

Save the device in a folder with a unique identifier. The folder will be created in the current directory.

.. GENERATED FROM PYTHON SOURCE LINES 165-177

.. code-block:: Python

    modifyDevice = False
    if not modifyDevice:
        newDevice.generateDeviceUUID()  # one time only
        newDevice.createDirectory()  # one time only
        storeDevice = StoreDeviceInFo(device_directory=newDevice.deviceDirectory)  # one time only
        device_path = newDevice.deviceDirectory
    else:
        device_path = "C:\\Users\\pedro\\OneDrive\\Documentos\\GitHub\\Infinity-Tomographic-Reconstruction\\configurations\\08d98d7f-a3c1-4cdf-a037-54655c7bdbb7_EasyCT"
        storeDevice = StoreDeviceInFo(device_directory=device_path)  # one time only

    storeDevice.createDeviceInDirectory(object=newDevice)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Device created successfully




.. GENERATED FROM PYTHON SOURCE LINES 178-181

----------
TESTS PART
Design the system at the initial position

.. GENERATED FROM PYTHON SOURCE LINES 181-189

.. code-block:: Python

    readDevice = StoreDeviceInFo(device_directory=device_path)  # read the device saved
    newDevice_Read = readDevice.readDeviceFromDirectory()

    designer = DeviceDesignerStandalone(device=newDevice)
    designer.addDevice()
    # designer.addxRayProducerSource()
    designer.startRender()








.. GENERATED FROM PYTHON SOURCE LINES 190-191

Test some initial positions of the source and the detectors

.. GENERATED FROM PYTHON SOURCE LINES 191-196

.. code-block:: Python


    unique_header = np.repeat(np.arange(0, 32), 13)
    axial_motor_angles = (np.zeros(32 * 13))
    fan_motor_angles = np.tile(np.arange(-90, 105, 15), 32)








.. GENERATED FROM PYTHON SOURCE LINES 197-230

Calculate the coordinates for the previous angles
newDevice.detectorSideBCoordinatesAfterMovement(axial_motor_angles, fan_motor_angles, unique_header)

axial_motor_angles = np.array([0, 0], dtype=np.float32)
fan_motor_angles = np.array([0, 0], dtype=np.float32)
# newDevice.sourcePositionAfterMovement(axial_motor_angles, fan_motor_angles)
plt.figure(figsize=(10, 10))
plt.plot(newDevice.originSystemWZ[0], newDevice.originSystemWZ[1], 'ro', label='Origin Fan Motor')
# plot source center
# plt.plot(newDevice.sourceCenter[:, 0], newDevice.sourceCenter[:, 1], 'bo', label='Source Center')
plt.plot(newDevice.originSystemXY[0], newDevice.originSystemXY[1], 'ko', label='Origin FOV')
plt.plot(newDevice.centerFace[:, 0], newDevice.centerFace[:, 1], 'go', label='Center Face Detector Module B')
plt.plot(newDevice._verticesB[:, :, 0], newDevice._verticesB[:, :, 1], 'mo', label='Vertices Base Detector Module B')

plt.plot([np.ones(newDevice.centerFace.shape[0]) * newDevice.originSystemWZ[0, 0],
          newDevice.centerFace[:, 0]], [np.ones(newDevice.centerFace.shape[0]) * newDevice.originSystemWZ[1, 0],
                                        newDevice.centerFace[:, 1]], '-')
plt.xlabel('X (mm)')
plt.ylabel('Z (mm)')
plt.legend()
plt.figure(figsize=(10, 10))

# x an Z direction
plt.plot(newDevice.originSystemWZ[0], newDevice.originSystemWZ[2], 'ro', label='Origin Fan Motor')
# plot source center
# plt.plot(newDevice.sourceCenter[:, 0], newDevice.sourceCenter[:, 2], 'bo', label='Source Center')
plt.plot(newDevice.originSystemXY[0], newDevice.originSystemXY[2], 'ko', label='Origin FOV')
# plt.plot(newDevice.centerFace[:, 0], newDevice.centerFace[:, 2], 'go', label='Center Face Detector Module B')
plt.plot(newDevice._verticesB[:, :, 0], newDevice._verticesB[:, :, 2], 'mo', label='Vertices Base Detector Module B')
plt.xlabel('X (mm)')
plt.ylabel('Y (mm)')
plt.legend()
plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.468 seconds)


.. _sphx_glr_download_auto_examples_iPET_1_Device_creation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 1_Device_creation.ipynb <1_Device_creation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 1_Device_creation.py <1_Device_creation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 1_Device_creation.zip <1_Device_creation.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
