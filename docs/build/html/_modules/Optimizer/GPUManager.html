
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Optimizer.GPUManager &#8212; Infinity-Tomographic-Reconstruction 0.1.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=c5ced968eda925caa686" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=c5ced968eda925caa686" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=c5ced968eda925caa686" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=c5ced968eda925caa686" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=c5ced968eda925caa686" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=c5ced968eda925caa686" />
  <script src="../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=c5ced968eda925caa686"></script>

    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/Optimizer/GPUManager';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Infinity-Tomographic-Reconstruction 0.1.0 documentation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Infinity-Tomographic-Reconstruction 0.1.0 documentation - Home"/>`);</script>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../modules.html">
                        src
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../auto_examples/index.html">
                        Examples
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../modules.html">
                        src
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../auto_examples/index.html">
                        Examples
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">Optimizer.GPUManager</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for Optimizer.GPUManager</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">array</span><span class="w"> </span><span class="kn">import</span> <span class="n">array</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pycuda.driver</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cuda</span>
<span class="c1"># import pycuda.autoinit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pycuda.compiler</span><span class="w"> </span><span class="kn">import</span> <span class="n">SourceModule</span>

<span class="c1"># from ..Segmentation.findisosurface import FindISOSurface</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.selectable_events</span><span class="w"> </span><span class="kn">import</span> <span class="n">ROIEvents</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.CPU</span><span class="w"> </span><span class="kn">import</span> <span class="n">IterativeAlgorithmCPU</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.gpu_shared_memory</span><span class="w"> </span><span class="kn">import</span> <span class="n">GPUSharedMemorySingleKernel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.gpu_multiple_kernel</span><span class="w"> </span><span class="kn">import</span> <span class="n">GPUSharedMemoryMultipleKernel</span>


<div class="viewcode-block" id="EM">
<a class="viewcode-back" href="../../Optimizer.html#Optimizer.GPUManager.EM">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EM</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">easypetdata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">planes_equation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;LM-MLEM&quot;</span><span class="p">,</span> <span class="n">algorithm_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">number_of_iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">number_of_subsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">projector_type</span><span class="o">=</span><span class="s2">&quot;Box Counts&quot;</span><span class="p">,</span>
                 <span class="n">normalization_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attenuation_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">attenuation_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">decay_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doi_correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doi_mapping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">normalization_calculation_flag</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scatter_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">scatter_angle_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cut_fov</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">cuda_drv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">GPU</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shared_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">saved_image_by_iteration</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pixeltoangle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">entry_im</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiple_kernel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">signals_interface</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">current_info_step</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">planes_equation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">easypetdata</span> <span class="o">=</span> <span class="n">easypetdata</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm_options</span> <span class="o">=</span> <span class="n">algorithm_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cuda_drv</span> <span class="o">=</span> <span class="n">cuda_drv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalization_calculation_flag</span> <span class="o">=</span> <span class="n">normalization_calculation_flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signals_interface</span> <span class="o">=</span> <span class="n">signals_interface</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_info_step</span> <span class="o">=</span> <span class="n">current_info_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span>  <span class="c1"># study directory</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_events</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">number_of_events</span>
        <span class="c1"># Algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_iterations</span> <span class="o">=</span> <span class="n">number_of_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_subsets</span> <span class="o">=</span> <span class="n">number_of_subsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saved_image_by_iteration</span> <span class="o">=</span> <span class="n">saved_image_by_iteration</span>

        <span class="c1"># Optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shared_memory</span> <span class="o">=</span> <span class="n">shared_memory</span>

        <span class="c1"># Geometry</span>

        <span class="c1"># self.crystal_central_planes = planes_equation.crystal_planes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">number_of_pixels_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">number_of_pixels_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">number_of_pixels_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">distance_to_central_plane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">distance_to_central_plane_normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">im_index_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">im_index_y</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">im_index_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">im_index_z</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">im_index_z</span>
        <span class="c1">#</span>
        <span class="c1"># self.p1_list = planes_equation.p1_list</span>
        <span class="c1"># self.p2_list = planes_equation.p2_list</span>
        <span class="c1"># self.p3_list = planes_equation.p3_list</span>
        <span class="c1"># self.p4_list = planes_equation.p4_list</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">d</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_normal</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">a_normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_normal</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">b_normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_normal</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">c_normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_normal</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">d_normal</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_cf</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">a_cf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_cf</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">b_cf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_cf</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">c_cf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_cf</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">d_cf</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">half_crystal_pitch_z</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">half_crystal_pitch_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_between_array_pixel</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">distance_between_array_pixel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">half_crystal_pitch_xy</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">half_crystal_pitch_xy</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_min_f</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">x_min_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max_f</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">x_max_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min_f</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">y_min_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max_f</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">y_max_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_min_f</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">z_min_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_max_f</span> <span class="o">=</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">z_max_f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">voxelSize</span> <span class="o">=</span><span class="p">[</span><span class="n">planes_equation</span><span class="o">.</span><span class="n">pixelSizeXY</span><span class="p">,</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">pixelSizeXY</span><span class="p">,</span> <span class="n">planes_equation</span><span class="o">.</span><span class="n">pixelSizeXYZ</span><span class="p">]</span>


        <span class="c1"># Corrections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isosurface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_y</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_z</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_coef</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span> <span class="o">=</span> <span class="n">doi_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span> <span class="o">=</span> <span class="n">time_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">time_correction</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projector_type</span> <span class="o">=</span> <span class="n">projector_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doi_correction</span> <span class="o">=</span> <span class="n">doi_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_correction</span> <span class="o">=</span> <span class="n">decay_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_correction</span> <span class="o">=</span> <span class="n">random_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter_correction</span> <span class="o">=</span> <span class="n">scatter_correction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter_angle_correction</span> <span class="o">=</span> <span class="n">scatter_angle_correction</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">normalization_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">normalize_sens_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span> <span class="o">=</span> <span class="n">normalization_matrix</span><span class="p">[</span>
                                            <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span>
                                                        <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                            <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:(</span>
                                                        <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                            <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]:(</span>
                                                        <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">normalize_sens_size</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

                <span class="n">normalize_sens_size_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normalize_sens_size</span><span class="p">)</span>
                <span class="n">rest</span> <span class="o">=</span> <span class="n">normalize_sens_size_abs</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">normalize_sens_size_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">normalize_sens_size_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="n">rest</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">normalize_sens_size_abs</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">normalize_sens_size_abs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">rest</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">normalize_sens_size_abs</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">normalize_sens_size_abs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">rest</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">normalization_matrix</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span> <span class="o">=</span> <span class="n">mask</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                            <span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># self.normalization_matrix = np.ascontiguousarray(self.normalization_matrix, dtype=np.float32)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">normalization_matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cut_fov</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_circular_mask_fov</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_initial_arrays</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pixeltoangle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_roi_map</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_active_roi_voxels</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_events_outside_ROI</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fullFoVPreviousProbability</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># self.normalization_matrix *= im</span>
                <span class="c1"># self.normalization_matrix /= np.sum(self.normalization_matrix)</span>
                <span class="c1"># self.normalization_matrix[self.normalization_matrix &lt; 0.00001] = 0</span>
                <span class="c1"># self.im = np.ascontiguousarray(self.im, dtype=np.float32)</span>
            <span class="c1"># self.im = np.ascontiguousarray(</span>
            <span class="c1">#     np.ones((self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
            <span class="c1">#             dtype=np.float32))</span>
            <span class="c1"># self.im = self.roi_map / np.max(self.roi_map)</span>
            <span class="c1">#     self.im = self.surface / np.max(self.surface)</span>
            <span class="c1">#     self.im = np.ascontiguousarray(self.im, dtype=np.float32)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span>

        <span class="c1"># if self.normalization_calculation_flag:</span>
        <span class="c1">#     self.im = np.ascontiguousarray(</span>
        <span class="c1">#         np.ones((self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
        <span class="c1">#                 dtype=np.float32))</span>
        <span class="c1">#     # self.im = self.roi_map / np.max(self.roi_map)</span>
        <span class="c1">#     self.im = self.surface / np.max(self.surface)</span>

        <span class="k">if</span> <span class="n">GPU</span><span class="p">:</span>

            <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multiple_kernel</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vor_design_gpu_shared_memory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_normal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_cf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">b_normal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_cf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">c_normal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_cf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_z</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_normal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_cf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjust_coef</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">half_crystal_pitch_xy</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">half_crystal_pitch_z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">normalization_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span><span class="p">)</span>
            <span class="c1">#     self.im = self._vor_design_gpu_shared_memory_multiple_reads(self.a, self.a_normal,self.a_cf, self.im_index_x, self.b, self.b_normal, self.b_cf, self.im_index_y, self.c, self.c_normal,self.c_cf,self.im_index_z,</span>
            <span class="c1">#                        self.d, self.d_normal, self.d_cf, self.adjust_coef, self.im, self.half_crystal_pitch_xy,</span>
            <span class="c1">#                                                  self.half_crystal_pitch_z, self.sum_pixel, self.sensivity_matrix,</span>
            <span class="c1">#                                                  self.normalization_matrix, self.time_correction)</span>
            <span class="k">elif</span> <span class="n">multiple_kernel</span><span class="p">:</span>
                <span class="n">gpu_alg</span> <span class="o">=</span> <span class="n">GPUSharedMemoryMultipleKernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimize_reads_and_calcs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># gpu_alg.multikernel_optimized_memory_reads()</span>
                <span class="n">gpu_alg</span><span class="o">.</span><span class="n">multiplekernel</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">gpu_alg</span><span class="o">.</span><span class="n">im</span>
                <span class="c1"># self.cdrf = True</span>
                <span class="c1"># self.im = self._vor_design_gpu_shared_memory_multiple_reads(self.a, self.a_normal, self.a_cf,</span>
                <span class="c1">#                                                             self.im_index_x, self.b,</span>
                <span class="c1">#                                                             self.b_normal, self.b_cf,</span>
                <span class="c1">#                                                             self.im_index_y, self.c,</span>
                <span class="c1">#                                                             self.c_normal, self.c_cf,</span>
                <span class="c1">#                                                             self.im_index_z,</span>
                <span class="c1">#                                                             self.d, self.d_normal, self.d_cf,</span>
                <span class="c1">#                                                             self.adjust_coef,</span>
                <span class="c1">#                                                             self.im, self.half_crystal_pitch_xy,</span>
                <span class="c1">#                                                             self.half_crystal_pitch_z,</span>
                <span class="c1">#                                                             self.sum_pixel,</span>
                <span class="c1">#                                                             self.fov_matrix_cut,</span>
                <span class="c1">#                                                             self.normalization_matrix,</span>
                <span class="c1">#                                                             self.time_correction)</span>
                <span class="c1"># # if use_half_precision:</span>
                <span class="c1">#     self.im = self._vor_design_gpu_shared_memory_multiple_reads_streamed(self.a, self.a_normal,</span>
                <span class="c1">#                                                                          self.a_cf, self.im_index_x,</span>
                <span class="c1">#                                                                          self.b,</span>
                <span class="c1">#                                                                          self.b_normal, self.b_cf,</span>
                <span class="c1">#                                                                          self.im_index_y, self.c,</span>
                <span class="c1">#                                                                          self.c_normal, self.c_cf,</span>
                <span class="c1">#                                                                          self.im_index_z,</span>
                <span class="c1">#                                                                          self.d, self.d_normal,</span>
                <span class="c1">#                                                                          self.d_cf, self.adjust_coef,</span>
                <span class="c1">#                                                                          self.im,</span>
                <span class="c1">#                                                                          self.half_crystal_pitch_xy,</span>
                <span class="c1">#                                                                          self.half_crystal_pitch_z,</span>
                <span class="c1">#                                                                          self.sum_pixel,</span>
                <span class="c1">#                                                                          self.fov_matrix_cut,</span>
                <span class="c1">#                                                                          self.normalization_matrix,</span>
                <span class="c1">#                                                                          self.time_correction)</span>
                <span class="c1"># else:</span>

            <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimizer CALCULATION OSEM: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">))</span>
            <span class="c1"># np.save(&#39;im.npy&#39;, im)</span>

            <span class="c1"># self.vor_design_cpu()</span>
            <span class="c1"># self.im =self.im_cpu-self.im</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cpu_alg</span> <span class="o">=</span> <span class="n">IterativeAlgorithmCPU</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">cpu_alg</span><span class="o">.</span><span class="n">im</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_calculation_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_image_by_it</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="EM.load_initial_arrays">
<a class="viewcode-back" href="../../Optimizer.html#Optimizer.GPUManager.EM.load_initial_arrays">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_initial_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attenuation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_calculation_flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">))</span> <span class="o">*</span> \
                      <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="c1"># self.im = np.ascontiguousarray(</span>
            <span class="c1">#     np.ones((self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
            <span class="c1">#             dtype=np.float32))</span>
            <span class="c1"># self.im = self.roi_map / np.max(self.roi_map)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">))</span> <span class="o">*</span> \
                          <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">))</span> <span class="o">*</span> \
                          <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="EM.get_active_roi_voxels">
<a class="viewcode-back" href="../../Optimizer.html#Optimizer.GPUManager.EM.get_active_roi_voxels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_active_roi_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isosurface</span> <span class="o">=</span> <span class="n">FindISOSurface</span><span class="p">(</span><span class="n">volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span><span class="p">,</span> <span class="n">directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">)</span>
        <span class="c1"># self.isosurface.threshold3DISOSurface()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isosurface</span><span class="o">.</span><span class="n">get_active_pixels</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isosurface</span><span class="o">.</span><span class="n">save_calculated_surface</span><span class="p">()</span>
        <span class="n">active_pixels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isosurface</span><span class="o">.</span><span class="n">active_pixels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isosurface</span><span class="o">.</span><span class="n">surface_volume</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_x</span> <span class="o">=</span> <span class="n">active_pixels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_y</span> <span class="o">=</span> <span class="n">active_pixels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_z</span> <span class="o">=</span> <span class="n">active_pixels</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_pixel_z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span></div>


        <span class="c1"># file_name = os.path.join(self.directory, &quot;map_total&quot;)</span>
        <span class="c1"># sizefile = self.number_of_pixels_x * self.number_of_pixels_y * self.number_of_pixels_z</span>
        <span class="c1"># output_file = open(file_name, &#39;rb&#39;)</span>
        <span class="c1"># a = array(&#39;f&#39;)</span>
        <span class="c1"># a.fromfile(output_file, sizefile)</span>
        <span class="c1"># output_file.close()</span>
        <span class="c1"># self.roi_map_total = np.array(a)</span>
        <span class="c1"># self.roi_map_total = self.roi_map.reshape(</span>
        <span class="c1">#     (self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
        <span class="c1">#     order=&#39;F&#39;)</span>

        <span class="c1"># self.im = np.ascontiguousarray(</span>
        <span class="c1">#     np.ones((self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
        <span class="c1">#             dtype=np.float32)) *self.surface</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fullFoVPreviousProbability</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;whole_body&quot;</span><span class="p">,</span> <span class="s2">&quot;ID_26 Jan 2022 - 14h 57m 00s_None_ IMAGE (154, 154, 373).T&quot;</span><span class="p">)</span>
            <span class="c1"># file_name = os.path.join(self.directory, &quot;map_heart&quot;)</span>
            <span class="n">sizefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span>
            <span class="c1"># sizefile = 101 * 101 * 153</span>
            <span class="n">sizeMatrix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">154</span><span class="p">,</span><span class="mi">154</span><span class="p">,</span><span class="mi">373</span><span class="p">]</span>
            <span class="n">sizefile</span> <span class="o">=</span> <span class="n">sizeMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">sizeMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sizeMatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">output_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">sizefile</span><span class="p">)</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">map_probability</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="c1"># self.roi_map = self.roi_map.reshape(</span>
            <span class="c1">#     (self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
            <span class="c1">#     order=&#39;F&#39;)</span>
            <span class="c1"># self.roi_map = self.roi_map.reshape(</span>
            <span class="c1">#     (101, 101, 153),</span>
            <span class="c1">#     order=&#39;F&#39;)</span>
            <span class="n">map_probability</span> <span class="o">=</span> <span class="n">map_probability</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="n">sizeMatrix</span><span class="p">),</span>
                <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.ndimage</span>
            <span class="n">map_probability</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="n">map_probability</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">])</span><span class="o">/</span><span class="n">map_probability</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">map_probability</span> <span class="o">=</span> <span class="n">map_probability</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">map_probability</span><span class="p">)</span>
            <span class="n">map_probability</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">map_probability</span>

        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="n">map_probability</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">map_probability</span>

<div class="viewcode-block" id="EM.load_roi_map">
<a class="viewcode-back" href="../../Optimizer.html#Optimizer.GPUManager.EM.load_roi_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_roi_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;map_2&quot;</span><span class="p">)</span>
            <span class="c1"># file_name = os.path.join(self.directory, &quot;map_heart&quot;)</span>
            <span class="n">sizefile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span>
            <span class="c1"># sizefile = 101 * 101 * 153</span>
            <span class="n">sizeMatrix</span> <span class="o">=</span> <span class="p">[</span><span class="mi">154</span><span class="p">,</span> <span class="mi">154</span><span class="p">,</span> <span class="mi">373</span><span class="p">]</span>
            <span class="n">sizefile</span> <span class="o">=</span> <span class="n">sizeMatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sizeMatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sizeMatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">output_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">sizefile</span><span class="p">)</span>
            <span class="n">output_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="c1"># self.roi_map = self.roi_map.reshape(</span>
            <span class="c1">#     (self.number_of_pixels_x, self.number_of_pixels_y, self.number_of_pixels_z),</span>
            <span class="c1">#     order=&#39;F&#39;)</span>
            <span class="c1"># self.roi_map = self.roi_map.reshape(</span>
            <span class="c1">#     (101, 101, 153),</span>
            <span class="c1">#     order=&#39;F&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="n">sizeMatrix</span><span class="p">),</span>
                <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">scipy.ndimage</span>
            <span class="n">pixel_size_roi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">])</span>
            <span class="n">pixel_size_image</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.8</span><span class="p">])</span>
            <span class="n">pixel_relation</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">((</span><span class="n">pixel_size_image</span><span class="o">/</span><span class="n">pixel_size_roi</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">zoom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span><span class="p">,</span> <span class="n">pixel_relation</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">sens_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">sens_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]:(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">sens_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">sens_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]:(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sens_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">sens_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]:(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">sens_size</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="c1"># sens_size = ((np.array(self.roi_map.shape) - np.array(self.im_index_x.shape)) / 2).astype(</span>
            <span class="c1">#     np.int16)</span>
            <span class="c1"># if sens_size[0] &gt;= 0:</span>
            <span class="c1">#     self.roi_map = self.roi_map[</span>
            <span class="c1">#                                 sens_size[0]:(</span>
            <span class="c1">#                                         self.roi_map.shape[0] - sens_size[0]),</span>
            <span class="c1">#                                 sens_size[1]:(</span>
            <span class="c1">#                                         self.roi_map.shape[1] - sens_size[1]),</span>
            <span class="c1">#                                 sens_size[2]:(</span>
            <span class="c1">#                                         self.roi_map.shape[2] - sens_size[2])]</span>

            <span class="c1"># self.roi_map = self.roi_map / self.roi_map</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_map</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="EM.remove_events_outside_ROI">
<a class="viewcode-back" href="../../Optimizer.html#Optimizer.GPUManager.EM.remove_events_outside_ROI">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_events_outside_ROI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">roievents</span> <span class="o">=</span> <span class="n">ROIEvents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">valid_vor</span> <span class="o">=</span> <span class="n">roievents</span><span class="o">.</span><span class="n">pixel2Position</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_normal</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_normal</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_normal</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_normal</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_cf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_cf</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_cf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b_cf</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_cf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_cf</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_cf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_cf</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># self.distance_between_array_pixel = self.distance_between_array_pixel[valid_vor == 1]</span>
        <span class="n">listmode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">easypetdata</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;_listmode.npy&quot;</span><span class="p">,</span> <span class="n">listmode</span><span class="p">)</span>
        <span class="n">listmode</span> <span class="o">=</span> <span class="n">listmode</span><span class="p">[</span><span class="n">valid_vor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;_listmode_cut.npy&quot;</span><span class="p">,</span> <span class="n">listmode</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_normal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_normal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_normal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_normal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a_cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_cf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b_cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_cf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c_cf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_cf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_correction</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_pixel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span><span class="p">,</span>
                                                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>


<div class="viewcode-block" id="EM.apply_circular_mask_fov">
<a class="viewcode-back" href="../../Optimizer.html#Optimizer.GPUManager.EM.apply_circular_mask_fov">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_circular_mask_fov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># correct xx and yy shape in case of missmatch</span>
        <span class="k">if</span> <span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">yy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span><span class="o">.</span><span class="n">T</span>
            <span class="n">yy</span><span class="o">=</span><span class="n">yy</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># circle_cut = xx + yy - (self.im_index_x.shape[1] * np.sin(np.radians(easypetdata.half_real_range))*0.5) ** 2</span>
        <span class="n">circle_cut</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="c1"># circle_cut = xx + yy - (self.im_index_x.shape[1] * np.sin(np.radians(120/2))*.50) ** 2</span>

        <span class="n">circle_cut</span><span class="p">[</span><span class="n">circle_cut</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">circle_cut</span><span class="p">[</span><span class="n">circle_cut</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">circle_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">circle_cut</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">im_index_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span> <span class="o">*</span> <span class="n">circle_cut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fov_matrix_cut</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span></div>

        <span class="c1"># calculate non-zero pixels</span>


    <span class="c1"># def _vor_design_gpu_shared_memory_multiple_reads(self, a, a_normal, a_cf, A, b, b_normal, b_cf, B, c, c_normal,</span>
    <span class="c1">#                                                  c_cf, C,</span>
    <span class="c1">#                                                  d, d_normal, d_cf, adjust_coef, im, half_crystal_pitch_xy,</span>
    <span class="c1">#                                                  half_crystal_pitch_z,</span>
    <span class="c1">#                                                  sum_vor, fov_cut_matrix, normalization_matrix, time_factor):</span>
    <span class="c1">#     print(&#39;Optimizer STARTED - Multiple reads&#39;)</span>
    <span class="c1">#     # cuda.init()</span>
    <span class="c1">#     cuda = self.cuda_drv</span>
    <span class="c1">#     # device = cuda.Device(0)  # enter your gpu id here</span>
    <span class="c1">#     # ctx = device.make_context()</span>
    <span class="c1">#     number_of_events = np.int32(len(a))</span>
    <span class="c1">#     weight = np.int32(A.shape[0])</span>
    <span class="c1">#     height = np.int32(A.shape[1])</span>
    <span class="c1">#     depth = np.int32(A.shape[2])</span>
    <span class="c1">#     # start_x = np.int32(A[0, 0, 0])</span>
    <span class="c1">#     start_x = np.int32(A[0, 0, 0])</span>
    <span class="c1">#     start_y = np.int32(B[0, 0, 0])</span>
    <span class="c1">#     start_z = np.int32(C[0, 0, 0])</span>
    <span class="c1">#     print(&quot;Start_point: {},{},{}&quot;.format(start_x, start_y, start_z))</span>
    <span class="c1">#     print(&#39;Image size: {},{}, {}&#39;.format(weight, height, depth))</span>
    <span class="c1">#</span>
    <span class="c1">#     half_distance_between_array_pixel = np.float32(self.distance_between_array_pixel / 2)</span>
    <span class="c1">#     normalization_matrix = normalization_matrix.reshape(</span>
    <span class="c1">#         normalization_matrix.shape[0] * normalization_matrix.shape[1] * normalization_matrix.shape[2])</span>
    <span class="c1">#</span>
    <span class="c1">#     # SOURCE MODELS (DEVICE CODE)</span>
    <span class="c1">#</span>
    <span class="c1">#     mod_forward_projection_shared_mem = SourceModule(&quot;&quot;&quot;</span>
    <span class="c1">#     #include &lt;stdint.h&gt;</span>
    <span class="c1">#</span>
    <span class="c1">#     texture&lt;char, 1&gt; tex;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#     __global__ void forward_projection</span>
    <span class="c1">#     (const int n, const int m, const int p, const int start_x, const int start_y, const int start_z,</span>
    <span class="c1">#     const float crystal_pitch_XY,const float crystal_pitch_Z,const float distance_between_array_pixel,</span>
    <span class="c1">#     int number_of_events, const int begin_event_gpu_limitation,  const int end_event_gpu_limitation,</span>
    <span class="c1">#     float *a, float *a_normal, float *a_cf, float *b,float *b_normal, float *b_cf,float *c,float *c_normal,</span>
    <span class="c1">#     float *c_cf, float *d, float *d_normal, float *d_cf, float *sum_vor, const char *fov_cut_matrix, const float *im_old)</span>
    <span class="c1">#                            {</span>
    <span class="c1">#                               const int shared_memory_size = 256;</span>
    <span class="c1">#                                __shared__ float a_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float b_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float c_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float d_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float a_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float b_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float c_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float d_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float a_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float b_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float c_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float d_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ float sum_vor_shared[shared_memory_size];</span>
    <span class="c1">#                                __shared__ char fov_cut_matrix_shared[shared_memory_size];</span>
    <span class="c1">#                                /*</span>
    <span class="c1">#                               const int blockId = blockIdx.x+ blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;</span>
    <span class="c1">#                               const int threadId= blockId * (blockDim.x * blockDim.y * blockDim.z)+ (threadIdx.z * (blockDim.x * blockDim.y))+ (threadIdx.y * blockDim.x)+ threadIdx.x;</span>
    <span class="c1">#                               */</span>
    <span class="c1">#                               int threadId=blockIdx.x *blockDim.x + threadIdx.x;</span>
    <span class="c1">#                               int e;</span>
    <span class="c1">#</span>
    <span class="c1">#                               float d2;</span>
    <span class="c1">#                               float d2_normal;</span>
    <span class="c1">#                               float d2_cf;</span>
    <span class="c1">#                               float value;</span>
    <span class="c1">#                               float value_normal;</span>
    <span class="c1">#                               float value_cf;</span>
    <span class="c1">#                               float sum_vor_temp;</span>
    <span class="c1">#                               int index;</span>
    <span class="c1">#                               int x_t;</span>
    <span class="c1">#                               int y_t;</span>
    <span class="c1">#                               int z_t;</span>
    <span class="c1">#                               float max_distance_projector;</span>
    <span class="c1">#                               const int number_events_max = end_event_gpu_limitation-begin_event_gpu_limitation;</span>
    <span class="c1">#                               const float error_pixel = 0.0000f;</span>
    <span class="c1">#                                if (threadIdx.x&gt;shared_memory_size)</span>
    <span class="c1">#                                {</span>
    <span class="c1">#                                return;</span>
    <span class="c1">#                                }</span>
    <span class="c1">#                                if(threadId&gt;number_events_max)</span>
    <span class="c1">#                                {</span>
    <span class="c1">#                                return;</span>
    <span class="c1">#                                }</span>
    <span class="c1">#</span>
    <span class="c1">#                               __syncthreads();</span>
    <span class="c1">#                               e = threadId;</span>
    <span class="c1">#                               int e_m = threadIdx.x;</span>
    <span class="c1">#                               a_shared[e_m] = a[e];</span>
    <span class="c1">#                               b_shared[e_m] = b[e];</span>
    <span class="c1">#                               c_shared[e_m] = c[e];</span>
    <span class="c1">#                               d_shared[e_m] = d[e];</span>
    <span class="c1">#                               a_normal_shared[e_m] = a_normal[e];</span>
    <span class="c1">#                               b_normal_shared[e_m] = b_normal[e];</span>
    <span class="c1">#                               c_normal_shared[e_m] = c_normal[e];</span>
    <span class="c1">#                               d_normal_shared[e_m] = d_normal[e];</span>
    <span class="c1">#                               a_cf_shared[e_m] = a_cf[e];</span>
    <span class="c1">#                               b_cf_shared[e_m] = b_cf[e];</span>
    <span class="c1">#                               c_cf_shared[e_m] = c_cf[e];</span>
    <span class="c1">#                               d_cf_shared[e_m] = d_cf[e];</span>
    <span class="c1">#                               sum_vor_shared[e_m] = sum_vor[e];</span>
    <span class="c1">#</span>
    <span class="c1">#                               d2_normal = crystal_pitch_XY * sqrt(a_normal_shared[e_m]*a_normal_shared[e_m]+b_normal_shared[e_m]*b_normal_shared[e_m]+c_normal_shared[e_m]*c_normal_shared[e_m]);</span>
    <span class="c1">#                               d2 = crystal_pitch_Z * sqrt(a_shared[e_m]*a_shared[e_m] + b_shared[e_m]*b_shared[e_m] + c_shared[e_m]*c_shared[e_m]);</span>
    <span class="c1">#                               d2_cf = distance_between_array_pixel*sqrt(a_cf_shared[e_m]*a_cf_shared[e_m]+b_cf_shared[e_m]*b_cf_shared[e_m]+c_cf_shared[e_m]*c_cf_shared[e_m]);</span>
    <span class="c1">#                               max_distance_projector=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf);</span>
    <span class="c1">#</span>
    <span class="c1">#                               for(int l=0; l&lt;n; l++)</span>
    <span class="c1">#                               {</span>
    <span class="c1">#                                   x_t = l+start_x;</span>
    <span class="c1">#                                   for(int j=0; j&lt;m; j++)</span>
    <span class="c1">#                                   {</span>
    <span class="c1">#                                      y_t = j+start_y;</span>
    <span class="c1">#                                      for(int k=0; k&lt;p; k++)</span>
    <span class="c1">#                                           {</span>
    <span class="c1">#                                           /*</span>
    <span class="c1">#                                           index = l+j*n+k*m*n;</span>
    <span class="c1">#                                           fov_cut_matrix_shared[k]=fov_cut_matrix[k+j*p+l*p*m];</span>
    <span class="c1">#                                           index = l+j*n+k*m*n;</span>
    <span class="c1">#                                           */</span>
    <span class="c1">#                                             index = k+j*p+l*p*m;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                           if (fov_cut_matrix[index]!=0)</span>
    <span class="c1">#                                           {</span>
    <span class="c1">#</span>
    <span class="c1">#                                               z_t = k+start_z;</span>
    <span class="c1">#                                               value_normal = a_normal_shared[e_m]*x_t+b_normal_shared[e_m]*y_t+c_normal_shared[e_m] * z_t -d_normal_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#                                                if (value_normal &lt; d2_normal &amp;&amp; value_normal &gt;= -d2_normal)</span>
    <span class="c1">#                                                {</span>
    <span class="c1">#                                                 value = a_shared[e_m]*x_t+b_shared[e_m]*y_t+c_shared[e_m]*z_t-d_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#                                                 if (value &lt; d2 &amp;&amp; value &gt;=-d2 )</span>
    <span class="c1">#                                                  {</span>
    <span class="c1">#                                                       value_cf = a_cf_shared[e_m]*x_t+b_cf_shared[e_m]*y_t+c_cf_shared[e_m]*z_t-d_cf_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                   if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
    <span class="c1">#                                                       {</span>
    <span class="c1">#</span>
    <span class="c1">#                                                        sum_vor_temp +=im_old[index]*(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector);</span>
    <span class="c1">#                                                        /* im_old[index]*(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector)</span>
    <span class="c1">#</span>
    <span class="c1">#                                                         */</span>
    <span class="c1">#                                                         }</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                               }</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                           }</span>
    <span class="c1">#                                           }</span>
    <span class="c1">#</span>
    <span class="c1">#                                        }</span>
    <span class="c1">#                                    }</span>
    <span class="c1">#                                }</span>
    <span class="c1">#</span>
    <span class="c1">#                                /*</span>
    <span class="c1">#                                 sum_vor[e]= sum_vor_temp;</span>
    <span class="c1">#                                sum_vor[e]= sum_vor_shared[e_m];</span>
    <span class="c1">#                                __syncthreads();</span>
    <span class="c1">#                                sum_vor[e]= sum_vor_shared[e_m];</span>
    <span class="c1">#                                */</span>
    <span class="c1">#                                sum_vor[e]= sum_vor_temp;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#            }&quot;&quot;&quot;)</span>
    <span class="c1">#     mod_normalization_shared_mem = SourceModule(&quot;&quot;&quot;</span>
    <span class="c1">#                          #include &lt;stdint.h&gt;</span>
    <span class="c1">#                          texture&lt;uint8_t, 1&gt; tex;</span>
    <span class="c1">#</span>
    <span class="c1">#                   __global__ void normalization</span>
    <span class="c1">#                    ( int dataset_number, int n, int m, int p, const float crystal_pitch_XY, const float crystal_pitch_Z,</span>
    <span class="c1">#                    const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation,</span>
    <span class="c1">#                    const int end_event_gpu_limitation, const float *a, const float *a_normal, const float *a_cf, const float *b,</span>
    <span class="c1">#                    const float *b_normal, const float *b_cf, const float *c, const float *c_normal, const float *c_cf, const float *d, const float *d_normal,</span>
    <span class="c1">#                    const float *d_cf, const short *A, const short *B, const short *C, float *adjust_coef, float *sum_vor,</span>
    <span class="c1">#                    char *fov_cut_matrix, float *time_factor)</span>
    <span class="c1">#                    {</span>
    <span class="c1">#                              extern __shared__ float adjust_coef_shared[];</span>
    <span class="c1">#                              int idt=blockIdx.x *blockDim.x + threadIdx.x;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                              float d2;</span>
    <span class="c1">#                              float d2_normal;</span>
    <span class="c1">#                              float d2_cf;</span>
    <span class="c1">#                              float normal_value;</span>
    <span class="c1">#                              float value;</span>
    <span class="c1">#                              float value_cf;</span>
    <span class="c1">#                              short a_temp;</span>
    <span class="c1">#                              short b_temp;</span>
    <span class="c1">#                              short c_temp;</span>
    <span class="c1">#                              char fov_cut_temp;</span>
    <span class="c1">#                              int i_s=threadIdx.x;</span>
    <span class="c1">#</span>
    <span class="c1">#                              if (idt&gt;n*m*p)</span>
    <span class="c1">#                              {</span>
    <span class="c1">#                                   return;</span>
    <span class="c1">#                               }</span>
    <span class="c1">#</span>
    <span class="c1">#                              __syncthreads();</span>
    <span class="c1">#                              adjust_coef_shared[i_s] = adjust_coef[idt];</span>
    <span class="c1">#                              a_temp = A[idt];</span>
    <span class="c1">#                              b_temp = B[idt];</span>
    <span class="c1">#                              c_temp = C[idt];</span>
    <span class="c1">#                              fov_cut_temp = fov_cut_matrix[idt];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                              for(int e=begin_event_gpu_limitation; e&lt;end_event_gpu_limitation; e++)</span>
    <span class="c1">#                              {</span>
    <span class="c1">#                                  if (fov_cut_temp!=0)</span>
    <span class="c1">#                                  {</span>
    <span class="c1">#                                  normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                  d2_normal = crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#                                  if (normal_value&lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
    <span class="c1">#                                  {</span>
    <span class="c1">#                                  value = a[e]*a_temp+b[e]*b_temp +c[e]*c_temp- d[e];</span>
    <span class="c1">#                                  d2 = crystal_pitch_Z * sqrt(a[e]*a[e] + b[e]*b[e] + c[e]*c[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                      if (value &lt; d2 &amp;&amp; value &gt;=-d2)</span>
    <span class="c1">#                                      {</span>
    <span class="c1">#                                                value_cf = a_cf[e]*a_temp+b_cf[e]*b_temp +c_cf[e] * c_temp-d_cf[e];</span>
    <span class="c1">#                                                d2_cf = distance_between_array_pixel*sqrt(a_cf[e]*a_cf[e]+b_cf[e]*b_cf[e]+c_cf[e]*c_cf[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                  if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
    <span class="c1">#                                                  {</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                         adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf));</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                 }</span>
    <span class="c1">#</span>
    <span class="c1">#                                                      /*</span>
    <span class="c1">#</span>
    <span class="c1">#                                                      adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf));</span>
    <span class="c1">#                                                      adjust_coef_shared[i_s] += 1/sum_vor[e];</span>
    <span class="c1">#                                                      normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                       d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#                                                     adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);</span>
    <span class="c1">#                                                    adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);</span>
    <span class="c1">#                                                       */</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                           }</span>
    <span class="c1">#                                       }</span>
    <span class="c1">#</span>
    <span class="c1">#                              }</span>
    <span class="c1">#</span>
    <span class="c1">#                              }</span>
    <span class="c1">#</span>
    <span class="c1">#                              adjust_coef[idt] = adjust_coef_shared[i_s];</span>
    <span class="c1">#                              __syncthreads();</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                          }</span>
    <span class="c1">#                          &quot;&quot;&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     mod_backward_projection_shared_mem = SourceModule(&quot;&quot;&quot;</span>
    <span class="c1">#                   #include &lt;stdint.h&gt;</span>
    <span class="c1">#                   texture&lt;uint8_t, 1&gt; tex;</span>
    <span class="c1">#</span>
    <span class="c1">#            __global__ void backprojection</span>
    <span class="c1">#             ( int dataset_number, int n, int m, int p, const float crystal_pitch_XY, const float crystal_pitch_Z,</span>
    <span class="c1">#             const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation,</span>
    <span class="c1">#             const int end_event_gpu_limitation, const float *a, const float *a_normal, const float *a_cf, const float *b,</span>
    <span class="c1">#             const float *b_normal, const float *b_cf, const float *c, const float *c_normal, const float *c_cf, const float *d, const float *d_normal,</span>
    <span class="c1">#             const float *d_cf, const short *A, const short *B, const short *C, float *adjust_coef, float *sum_vor,</span>
    <span class="c1">#             char *fov_cut_matrix, float *time_factor)</span>
    <span class="c1">#             {</span>
    <span class="c1">#                       extern __shared__ float adjust_coef_shared[];</span>
    <span class="c1">#                       int idt=blockIdx.x *blockDim.x + threadIdx.x;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                       float d2;</span>
    <span class="c1">#                       float d2_normal;</span>
    <span class="c1">#                       float d2_cf;</span>
    <span class="c1">#                       float normal_value;</span>
    <span class="c1">#                       float value;</span>
    <span class="c1">#                       float value_cf;</span>
    <span class="c1">#                       short a_temp;</span>
    <span class="c1">#                       short b_temp;</span>
    <span class="c1">#                       short c_temp;</span>
    <span class="c1">#                       char fov_cut_temp;</span>
    <span class="c1">#                       int i_s=threadIdx.x;</span>
    <span class="c1">#</span>
    <span class="c1">#                       if (idt&gt;n*m*p)</span>
    <span class="c1">#                       {</span>
    <span class="c1">#                            return;</span>
    <span class="c1">#                        }</span>
    <span class="c1">#</span>
    <span class="c1">#                       __syncthreads();</span>
    <span class="c1">#                       adjust_coef_shared[i_s] = adjust_coef[idt];</span>
    <span class="c1">#                       a_temp = A[idt];</span>
    <span class="c1">#                       b_temp = B[idt];</span>
    <span class="c1">#                       c_temp = C[idt];</span>
    <span class="c1">#                       fov_cut_temp = fov_cut_matrix[idt];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                       for(int e=begin_event_gpu_limitation; e&lt;end_event_gpu_limitation; e++)</span>
    <span class="c1">#                       {</span>
    <span class="c1">#                           if (fov_cut_temp!=0)</span>
    <span class="c1">#                           {</span>
    <span class="c1">#                           normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                           d2_normal = crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#                           if (normal_value&lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
    <span class="c1">#                           {</span>
    <span class="c1">#                           value = a[e]*a_temp+b[e]*b_temp +c[e]*c_temp- d[e];</span>
    <span class="c1">#                           d2 = crystal_pitch_Z * sqrt(a[e]*a[e] + b[e]*b[e] + c[e]*c[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                               if (value &lt; d2 &amp;&amp; value &gt;=-d2)</span>
    <span class="c1">#                               {</span>
    <span class="c1">#                                         value_cf = a_cf[e]*a_temp+b_cf[e]*b_temp +c_cf[e] * c_temp-d_cf[e];</span>
    <span class="c1">#                                         d2_cf = distance_between_array_pixel*sqrt(a_cf[e]*a_cf[e]+b_cf[e]*b_cf[e]+c_cf[e]*c_cf[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                           if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
    <span class="c1">#                                           {</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                 adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]*time_factor[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#                                          }</span>
    <span class="c1">#</span>
    <span class="c1">#                                               /*</span>
    <span class="c1">#</span>
    <span class="c1">#                                               adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]*time_factor[e]);</span>
    <span class="c1">#                                               adjust_coef_shared[i_s] += 1/sum_vor[e];</span>
    <span class="c1">#                                               normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#                                              adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);</span>
    <span class="c1">#                                             adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);</span>
    <span class="c1">#                                                */</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                    }</span>
    <span class="c1">#                                }</span>
    <span class="c1">#</span>
    <span class="c1">#                       }</span>
    <span class="c1">#</span>
    <span class="c1">#                       }</span>
    <span class="c1">#</span>
    <span class="c1">#                       adjust_coef[idt] = adjust_coef_shared[i_s];</span>
    <span class="c1">#                       __syncthreads();</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                   }</span>
    <span class="c1">#                   &quot;&quot;&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     mod_forward_projection_shared_mem_cdrf = SourceModule(&quot;&quot;&quot;</span>
    <span class="c1">#            #include &lt;stdint.h&gt;</span>
    <span class="c1">#</span>
    <span class="c1">#            texture&lt;char, 1&gt; tex;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#            __global__ void forward_projection_cdrf</span>
    <span class="c1">#            (const int n, const int m, const int p, const int start_x, const int start_y, const int start_z,</span>
    <span class="c1">#            float *crystal_pitch_XY, float *crystal_pitch_Z,const float distance_between_array_pixel,</span>
    <span class="c1">#            int number_of_events, const int begin_event_gpu_limitation,  const int end_event_gpu_limitation,</span>
    <span class="c1">#            float *a, float *a_normal, float *a_cf, float *b,float *b_normal, float *b_cf,float *c,float *c_normal,</span>
    <span class="c1">#            float *c_cf, float *d, float *d_normal, float *d_cf, float *sum_vor, const char *fov_cut_matrix, const float *im_old)</span>
    <span class="c1">#                                   {</span>
    <span class="c1">#                                      const int shared_memory_size = 256;</span>
    <span class="c1">#                                       __shared__ float a_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float b_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float c_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float d_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float a_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float b_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float c_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float d_normal_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float a_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float b_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float c_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float d_cf_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float sum_vor_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ char fov_cut_matrix_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float crystal_pitch_Z_shared[shared_memory_size];</span>
    <span class="c1">#                                       __shared__ float crystal_pitch_XY_shared[shared_memory_size];</span>
    <span class="c1">#                                       /*</span>
    <span class="c1">#                                      const int blockId = blockIdx.x+ blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;</span>
    <span class="c1">#                                      const int threadId= blockId * (blockDim.x * blockDim.y * blockDim.z)+ (threadIdx.z * (blockDim.x * blockDim.y))+ (threadIdx.y * blockDim.x)+ threadIdx.x;</span>
    <span class="c1">#                                      */</span>
    <span class="c1">#                                      int threadId=blockIdx.x *blockDim.x + threadIdx.x;</span>
    <span class="c1">#                                      int e;</span>
    <span class="c1">#</span>
    <span class="c1">#                                      float d2;</span>
    <span class="c1">#                                      float d2_normal;</span>
    <span class="c1">#                                      float d2_cf;</span>
    <span class="c1">#                                      float value;</span>
    <span class="c1">#                                      float value_normal;</span>
    <span class="c1">#                                      float value_cf;</span>
    <span class="c1">#                                      float sum_vor_temp;</span>
    <span class="c1">#                                      int index;</span>
    <span class="c1">#                                      int x_t;</span>
    <span class="c1">#                                      int y_t;</span>
    <span class="c1">#                                      int z_t;</span>
    <span class="c1">#                                           float width;</span>
    <span class="c1">#                                       float height;</span>
    <span class="c1">#                                     float distance;</span>
    <span class="c1">#                                     float distance_other;</span>
    <span class="c1">#                                     float solid_angle;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                      float max_distance_projector;</span>
    <span class="c1">#</span>
    <span class="c1">#                                      const int number_events_max = end_event_gpu_limitation-begin_event_gpu_limitation;</span>
    <span class="c1">#                                      const float error_pixel = 0.0000f;</span>
    <span class="c1">#                                       if (threadIdx.x&gt;shared_memory_size)</span>
    <span class="c1">#                                       {</span>
    <span class="c1">#                                       return;</span>
    <span class="c1">#                                       }</span>
    <span class="c1">#                                       if(threadId&gt;number_events_max)</span>
    <span class="c1">#                                       {</span>
    <span class="c1">#                                       return;</span>
    <span class="c1">#                                       }</span>
    <span class="c1">#</span>
    <span class="c1">#                                      __syncthreads();</span>
    <span class="c1">#                                      e = threadId;</span>
    <span class="c1">#                                      int e_m = threadIdx.x;</span>
    <span class="c1">#                                      a_shared[e_m] = a[e];</span>
    <span class="c1">#                                      b_shared[e_m] = b[e];</span>
    <span class="c1">#                                      c_shared[e_m] = c[e];</span>
    <span class="c1">#                                      d_shared[e_m] = d[e];</span>
    <span class="c1">#                                      a_normal_shared[e_m] = a_normal[e];</span>
    <span class="c1">#                                      b_normal_shared[e_m] = b_normal[e];</span>
    <span class="c1">#                                      c_normal_shared[e_m] = c_normal[e];</span>
    <span class="c1">#                                      d_normal_shared[e_m] = d_normal[e];</span>
    <span class="c1">#                                      a_cf_shared[e_m] = a_cf[e];</span>
    <span class="c1">#                                      b_cf_shared[e_m] = b_cf[e];</span>
    <span class="c1">#                                      c_cf_shared[e_m] = c_cf[e];</span>
    <span class="c1">#                                      d_cf_shared[e_m] = d_cf[e];</span>
    <span class="c1">#                                      sum_vor_shared[e_m] = sum_vor[e];</span>
    <span class="c1">#                                      crystal_pitch_Z_shared[e_m] =  crystal_pitch_Z[e];</span>
    <span class="c1">#                                      crystal_pitch_XY_shared[e_m] =  crystal_pitch_XY[e];</span>
    <span class="c1">#</span>
    <span class="c1">#                                      d2_normal = crystal_pitch_XY_shared[e_m] * sqrt(a_normal_shared[e_m]*a_normal_shared[e_m]+b_normal_shared[e_m]*b_normal_shared[e_m]+c_normal_shared[e_m]*c_normal_shared[e_m]);</span>
    <span class="c1">#                                      d2 = crystal_pitch_Z_shared[e_m]* sqrt(a_shared[e_m]*a_shared[e_m] + b_shared[e_m]*b_shared[e_m] + c_shared[e_m]*c_shared[e_m]);</span>
    <span class="c1">#                                      d2_cf = distance_between_array_pixel*sqrt(a_cf_shared[e_m]*a_cf_shared[e_m]+b_cf_shared[e_m]*b_cf_shared[e_m]+c_cf_shared[e_m]*c_cf_shared[e_m]);</span>
    <span class="c1">#                                      max_distance_projector=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf);</span>
    <span class="c1">#</span>
    <span class="c1">#                                      for(int l=0; l&lt;n; l++)</span>
    <span class="c1">#                                      {</span>
    <span class="c1">#                                          x_t = l+start_x;</span>
    <span class="c1">#                                          for(int j=0; j&lt;m; j++)</span>
    <span class="c1">#                                          {</span>
    <span class="c1">#                                             y_t = j+start_y;</span>
    <span class="c1">#                                             for(int k=0; k&lt;p; k++)</span>
    <span class="c1">#                                                  {</span>
    <span class="c1">#                                                  /*</span>
    <span class="c1">#                                                  index = l+j*n+k*m*n;</span>
    <span class="c1">#                                                  fov_cut_matrix_shared[k]=fov_cut_matrix[k+j*p+l*p*m];</span>
    <span class="c1">#                                                  index = l+j*n+k*m*n;</span>
    <span class="c1">#                                                  */</span>
    <span class="c1">#                                                    index = k+j*p+l*p*m;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                  if (fov_cut_matrix[index]!=0)</span>
    <span class="c1">#                                                  {</span>
    <span class="c1">#</span>
    <span class="c1">#                                                      z_t = k+start_z;</span>
    <span class="c1">#                                                      value_normal = a_normal_shared[e_m]*x_t+b_normal_shared[e_m]*y_t+c_normal_shared[e_m] * z_t -d_normal_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#                                                       if (value_normal &lt; d2_normal &amp;&amp; value_normal &gt;= -d2_normal)</span>
    <span class="c1">#                                                       {</span>
    <span class="c1">#                                                        value = a_shared[e_m]*x_t+b_shared[e_m]*y_t+c_shared[e_m]*z_t-d_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#                                                        if (value &lt; d2 &amp;&amp; value &gt;=-d2 )</span>
    <span class="c1">#                                                         {</span>
    <span class="c1">#                                                              value_cf = a_cf_shared[e_m]*x_t+b_cf_shared[e_m]*y_t+c_cf_shared[e_m]*z_t-d_cf_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                          if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
    <span class="c1">#                                                              {</span>
    <span class="c1">#                                                              if (sqrt(value*value+value_normal*value_normal+value_cf*value_cf)&lt;=max_distance_projector)</span>
    <span class="c1">#                                                              {</span>
    <span class="c1">#                                                                  width = 2*(crystal_pitch_Z_shared[e_m]  - abs(value));</span>
    <span class="c1">#                                                                 height = 2*(crystal_pitch_XY_shared[e_m] - abs(value_normal));</span>
    <span class="c1">#</span>
    <span class="c1">#                                                                  distance =d2_cf+abs(value_cf);</span>
    <span class="c1">#                                                                 distance_other = abs(d2_cf+value_cf);</span>
    <span class="c1">#                                                                 solid_angle = 4*(width*width*height*height/(distance*distance*(4*distance*distance+width*width+height*height)));</span>
    <span class="c1">#                                                               sum_vor_shared[e_m]+= im_old[index]*solid_angle;</span>
    <span class="c1">#</span>
    <span class="c1">#                                                               }</span>
    <span class="c1">#                                                               /*</span>
    <span class="c1">#                                                               sum_vor_shared[e_m]+= im_old[index]*(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector);</span>
    <span class="c1">#                                                               4*arctan(</span>
    <span class="c1">#                                                               4*np.arctan(width*height/(2*distance_to_anh*np.sqrt(4*distance_between_array_pixel-value_cf)**2+width**2+height**2)))</span>
    <span class="c1">#                                                               *(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector)</span>
    <span class="c1">#                                                               */</span>
    <span class="c1">#                                                                }</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                      }</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                  }</span>
    <span class="c1">#                                                  }</span>
    <span class="c1">#</span>
    <span class="c1">#                                               }</span>
    <span class="c1">#                                           }</span>
    <span class="c1">#                                       }</span>
    <span class="c1">#</span>
    <span class="c1">#                                       /*</span>
    <span class="c1">#                                        sum_vor[e]= sum_vor_temp;</span>
    <span class="c1">#                                       sum_vor[e]= sum_vor_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                       sum_vor[e]= sum_vor_temp;</span>
    <span class="c1">#                                       */</span>
    <span class="c1">#                                       __syncthreads();</span>
    <span class="c1">#                                       sum_vor[e]= sum_vor_shared[e_m];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                   }&quot;&quot;&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     mod_normalization_shared_mem_cdrf = SourceModule(&quot;&quot;&quot;</span>
    <span class="c1">#                                  #include &lt;stdint.h&gt;</span>
    <span class="c1">#                                  texture&lt;uint8_t, 1&gt; tex;</span>
    <span class="c1">#</span>
    <span class="c1">#                           __global__ void normalization_cdrf</span>
    <span class="c1">#                            ( int dataset_number, int n, int m, int p, float *crystal_pitch_XY,  float *crystal_pitch_Z,</span>
    <span class="c1">#                            const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation,</span>
    <span class="c1">#                            const int end_event_gpu_limitation, const float *a, const float *a_normal, const float *a_cf, const float *b,</span>
    <span class="c1">#                            const float *b_normal, const float *b_cf, const float *c, const float *c_normal, const float *c_cf, const float *d, const float *d_normal,</span>
    <span class="c1">#                            const float *d_cf, const short *A, const short *B, const short *C, float *adjust_coef, float *sum_vor,</span>
    <span class="c1">#                            char *fov_cut_matrix, float *time_factor)</span>
    <span class="c1">#                            {</span>
    <span class="c1">#                                      extern __shared__ float adjust_coef_shared[];</span>
    <span class="c1">#                                      int idt=blockIdx.x *blockDim.x + threadIdx.x;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                      float d2;</span>
    <span class="c1">#                                      float d2_normal;</span>
    <span class="c1">#                                      float d2_cf;</span>
    <span class="c1">#                                      float normal_value;</span>
    <span class="c1">#                                      float value;</span>
    <span class="c1">#                                      float value_cf;</span>
    <span class="c1">#                                      short a_temp;</span>
    <span class="c1">#                                      short b_temp;</span>
    <span class="c1">#                                      short c_temp;</span>
    <span class="c1">#                                      char fov_cut_temp;</span>
    <span class="c1">#                                      int i_s=threadIdx.x;</span>
    <span class="c1">#                                      float width;</span>
    <span class="c1">#                                     float height;</span>
    <span class="c1">#                                     float distance;</span>
    <span class="c1">#                                     float distance_other;</span>
    <span class="c1">#                                      float solid_angle;</span>
    <span class="c1">#</span>
    <span class="c1">#                                      if (idt&gt;=n*m*p)</span>
    <span class="c1">#                                      {</span>
    <span class="c1">#                                           return;</span>
    <span class="c1">#                                       }</span>
    <span class="c1">#</span>
    <span class="c1">#                                      __syncthreads();</span>
    <span class="c1">#                                      adjust_coef_shared[i_s] = adjust_coef[idt];</span>
    <span class="c1">#                                      a_temp = A[idt];</span>
    <span class="c1">#                                      b_temp = B[idt];</span>
    <span class="c1">#                                      c_temp = C[idt];</span>
    <span class="c1">#                                      fov_cut_temp = fov_cut_matrix[idt];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                      for(int e=begin_event_gpu_limitation; e&lt;end_event_gpu_limitation; e++)</span>
    <span class="c1">#                                      {</span>
    <span class="c1">#                                          if (fov_cut_temp!=0)</span>
    <span class="c1">#                                          {</span>
    <span class="c1">#                                          normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                          d2_normal =  crystal_pitch_XY[e]* sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#                                          if (normal_value&lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
    <span class="c1">#                                          {</span>
    <span class="c1">#                                          value = a[e]*a_temp+b[e]*b_temp +c[e]*c_temp- d[e];</span>
    <span class="c1">#                                          d2 = crystal_pitch_Z[e] * sqrt(a[e]*a[e] + b[e]*b[e] + c[e]*c[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                              if (value &lt; d2 &amp;&amp; value &gt;=-d2)</span>
    <span class="c1">#                                              {</span>
    <span class="c1">#                                                        value_cf = a_cf[e]*a_temp+b_cf[e]*b_temp +c_cf[e] * c_temp-d_cf[e];</span>
    <span class="c1">#                                                        d2_cf = distance_between_array_pixel*sqrt(a_cf[e]*a_cf[e]+b_cf[e]*b_cf[e]+c_cf[e]*c_cf[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                          if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
    <span class="c1">#                                                          {</span>
    <span class="c1">#                                                             if (sqrt(value*value+normal_value*normal_value+value_cf*value_cf)&lt;=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))</span>
    <span class="c1">#                                                             {</span>
    <span class="c1">#                                                              width = 2*(crystal_pitch_Z[e]- abs(value));</span>
    <span class="c1">#                                                             height = 2*(crystal_pitch_XY[e] - abs(normal_value));</span>
    <span class="c1">#                                                             distance =d2_cf+abs(value_cf);</span>
    <span class="c1">#</span>
    <span class="c1">#                                                             solid_angle = 4*(width*width*height*height/(distance*distance*(4*distance*distance+width*width+height*height)));</span>
    <span class="c1">#                                                              adjust_coef_shared[i_s] += solid_angle/(sum_vor[e]);</span>
    <span class="c1">#                                                             /*</span>
    <span class="c1">#                                                             distance_other =d2_cf-abs(value_cf);</span>
    <span class="c1">#                                                             solid_angle = 4*(width*height/(2*distance*sqrt(4*distance*distance+width*width+height*height)));</span>
    <span class="c1">#                                                                adjust_coef_shared[i_s] += time_factor[e]*(1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]);</span>
    <span class="c1">#                                                               */</span>
    <span class="c1">#                                                                }</span>
    <span class="c1">#</span>
    <span class="c1">#                                                         }</span>
    <span class="c1">#</span>
    <span class="c1">#                                                              /*</span>
    <span class="c1">#                                                              (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/</span>
    <span class="c1">#                                                              normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                               d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#                                                             adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);</span>
    <span class="c1">#                                                            adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);</span>
    <span class="c1">#                                                               */</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                   }</span>
    <span class="c1">#                                               }</span>
    <span class="c1">#</span>
    <span class="c1">#                                      }</span>
    <span class="c1">#</span>
    <span class="c1">#                                      }</span>
    <span class="c1">#</span>
    <span class="c1">#                                      adjust_coef[idt] = adjust_coef_shared[i_s];</span>
    <span class="c1">#                                      __syncthreads();</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                  }</span>
    <span class="c1">#                                  &quot;&quot;&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     mod_backward_projection_shared_mem_cdrf = SourceModule(&quot;&quot;&quot;</span>
    <span class="c1">#                                 #include &lt;stdint.h&gt;</span>
    <span class="c1">#                                 texture&lt;uint8_t, 1&gt; tex;</span>
    <span class="c1">#</span>
    <span class="c1">#                          __global__ void backprojection_cdrf</span>
    <span class="c1">#                           ( int dataset_number, int n, int m, int p, const float *crystal_pitch_XY,  const float *crystal_pitch_Z,</span>
    <span class="c1">#                           const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation,</span>
    <span class="c1">#                           const int end_event_gpu_limitation, const float *a, const float *a_normal, const float *a_cf, const float *b,</span>
    <span class="c1">#                           const float *b_normal, const float *b_cf, const float *c, const float *c_normal, const float *c_cf, const float *d, const float *d_normal,</span>
    <span class="c1">#                           const float *d_cf, const short *A, const short *B, const short *C, float *adjust_coef, float *sum_vor,</span>
    <span class="c1">#                           char *fov_cut_matrix, float *time_factor)</span>
    <span class="c1">#                           {</span>
    <span class="c1">#                                     extern __shared__ float adjust_coef_shared[];</span>
    <span class="c1">#                                     int idt=blockIdx.x *blockDim.x + threadIdx.x;</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                     float d2;</span>
    <span class="c1">#                                     float d2_normal;</span>
    <span class="c1">#                                     float d2_cf;</span>
    <span class="c1">#                                     float normal_value;</span>
    <span class="c1">#                                     float value;</span>
    <span class="c1">#                                     float value_cf;</span>
    <span class="c1">#                                     short a_temp;</span>
    <span class="c1">#                                     short b_temp;</span>
    <span class="c1">#                                     short c_temp;</span>
    <span class="c1">#                                     char fov_cut_temp;</span>
    <span class="c1">#                                     int i_s=threadIdx.x;</span>
    <span class="c1">#                                     float width;</span>
    <span class="c1">#                                     float height;</span>
    <span class="c1">#                                     float distance;</span>
    <span class="c1">#                                     float distance_other;</span>
    <span class="c1">#                                     float solid_angle;</span>
    <span class="c1">#</span>
    <span class="c1">#                                     if (idt&gt;=n*m*p)</span>
    <span class="c1">#                                     {</span>
    <span class="c1">#                                          return;</span>
    <span class="c1">#                                      }</span>
    <span class="c1">#</span>
    <span class="c1">#                                     __syncthreads();</span>
    <span class="c1">#                                     adjust_coef_shared[i_s] = adjust_coef[idt];</span>
    <span class="c1">#                                     a_temp = A[idt];</span>
    <span class="c1">#                                     b_temp = B[idt];</span>
    <span class="c1">#                                     c_temp = C[idt];</span>
    <span class="c1">#</span>
    <span class="c1">#                                     fov_cut_temp = fov_cut_matrix[idt];</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                     for(int e=begin_event_gpu_limitation; e&lt;end_event_gpu_limitation; e++)</span>
    <span class="c1">#                                     {</span>
    <span class="c1">#                                         if (fov_cut_temp!=0)</span>
    <span class="c1">#                                         {</span>
    <span class="c1">#                                         normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                         d2_normal =  crystal_pitch_XY[e]* sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#                                         if (normal_value&lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
    <span class="c1">#                                         {</span>
    <span class="c1">#                                         value = a[e]*a_temp+b[e]*b_temp +c[e]*c_temp- d[e];</span>
    <span class="c1">#                                         d2 = crystal_pitch_Z[e] * sqrt(a[e]*a[e] + b[e]*b[e] + c[e]*c[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                             if (value &lt; d2 &amp;&amp; value &gt;=-d2)</span>
    <span class="c1">#                                             {</span>
    <span class="c1">#                                                       value_cf = a_cf[e]*a_temp+b_cf[e]*b_temp +c_cf[e] * c_temp-d_cf[e];</span>
    <span class="c1">#                                                       d2_cf = distance_between_array_pixel*sqrt(a_cf[e]*a_cf[e]+b_cf[e]*b_cf[e]+c_cf[e]*c_cf[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                         if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
    <span class="c1">#                                                         {</span>
    <span class="c1">#                                                            if (sqrt(value*value+normal_value*normal_value+value_cf*value_cf)&lt;=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))</span>
    <span class="c1">#                                                            {</span>
    <span class="c1">#                                                            width = 2*(crystal_pitch_Z[e]- abs(value));</span>
    <span class="c1">#                                                            height = 2*(crystal_pitch_XY[e] - abs(normal_value));</span>
    <span class="c1">#                                                            distance =d2_cf+abs(value_cf);</span>
    <span class="c1">#                                                            distance_other =d2_cf-abs(value_cf);</span>
    <span class="c1">#                                                            solid_angle = 4*(width*width*height*height/(distance*distance*(4*distance*distance+width*width+height*height)));</span>
    <span class="c1">#                                                            if (sum_vor[e]!=0)</span>
    <span class="c1">#</span>
    <span class="c1">#                                                             {</span>
    <span class="c1">#                                                             adjust_coef_shared[i_s] += solid_angle/(sum_vor[e]);</span>
    <span class="c1">#                                                             }</span>
    <span class="c1">#                                                              /*</span>
    <span class="c1">#                                                              (4 * asin(sin(tan(width/distance))*sin(tan(height/distance))))*(4 * asin(sin(tan(width/distance))*sin(tan(height/distance))))/sum_vor[e];</span>
    <span class="c1">#                                                          adjust_coef_shared[i_s] += time_factor[e]*(1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]);</span>
    <span class="c1">#</span>
    <span class="c1">#                                                              */</span>
    <span class="c1">#                                                               }</span>
    <span class="c1">#</span>
    <span class="c1">#                                                        }</span>
    <span class="c1">#</span>
    <span class="c1">#                                                             /*</span>
    <span class="c1">#                                                             (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/</span>
    <span class="c1">#                                                             normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
    <span class="c1">#                                              d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
    <span class="c1">#                                                            adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);</span>
    <span class="c1">#                                                           adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);</span>
    <span class="c1">#                                                              */</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                                  }</span>
    <span class="c1">#                                              }</span>
    <span class="c1">#</span>
    <span class="c1">#                                     }</span>
    <span class="c1">#</span>
    <span class="c1">#                                     }</span>
    <span class="c1">#</span>
    <span class="c1">#                                     adjust_coef[idt] = adjust_coef_shared[i_s];</span>
    <span class="c1">#                                     __syncthreads();</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                                 }</span>
    <span class="c1">#                                 &quot;&quot;&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     # float crystal_pitch, int number_of_events, float *a, float *b, float *c, float *d, int *A, int *B, int *C, float *im, float *vector_matrix</span>
    <span class="c1">#     # Host Code   B, C, im, vector_matrix,</span>
    <span class="c1">#     number_of_datasets = np.int32(1)  # Number of datasets (and concurrent operations) used.</span>
    <span class="c1">#     number_of_datasets_back = np.int32(1)  # Number of datasets (and concurrent operations) used.</span>
    <span class="c1">#     # Start concurrency Test</span>
    <span class="c1">#     # Event as reference point</span>
    <span class="c1">#     ref = cuda.Event()</span>
    <span class="c1">#     ref.record()</span>
    <span class="c1">#</span>
    <span class="c1">#     # Create the streams and events needed to calculation</span>
    <span class="c1">#     stream, event = [], []</span>
    <span class="c1">#     marker_names = [&#39;kernel_begin&#39;, &#39;kernel_end&#39;]</span>
    <span class="c1">#     # Create List to allocate chunks of data</span>
    <span class="c1">#     A_cut_gpu, B_cut_gpu, C_cut_gpu = [None] * number_of_datasets, [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets</span>
    <span class="c1">#     A_cut, B_cut, C_cut = [None] * number_of_datasets, [None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     a_gpu, b_gpu, c_gpu, d_gpu = [None] * number_of_datasets, [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#     a_normal_gpu, b_normal_gpu, c_normal_gpu, d_normal_gpu = [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     a_cut, b_cut, c_cut, d_cut = [None] * number_of_datasets, [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#     a_normal_cut, b_normal_cut, c_normal_cut, d_normal_cut = [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     a_cf_cut, b_cf_cut, c_cf_cut, d_cf_cut = [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     a_cut_gpu, b_cut_gpu, c_cut_gpu, d_cut_gpu = [None] * number_of_datasets, [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     a_cut_normal_gpu, b_cut_normal_gpu, c_cut_normal_gpu, d_cut_normal_gpu = [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     a_cf_cut_gpu, b_cf_cut_gpu, c_cf_cut_gpu, d_cf_cut_gpu = [None] * number_of_datasets, [</span>
    <span class="c1">#         None] * number_of_datasets, [None] * number_of_datasets, [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     time_factor_cut_gpu = [None] * number_of_datasets</span>
    <span class="c1">#     sum_vor_gpu = [None] * number_of_datasets</span>
    <span class="c1">#     sum_vor_cut = [None] * number_of_datasets</span>
    <span class="c1">#     probability_cut = [None] * number_of_datasets</span>
    <span class="c1">#     probability_gpu = [None] * number_of_datasets</span>
    <span class="c1">#     adjust_coef_cut = [None] * number_of_datasets</span>
    <span class="c1">#     adjust_coef_gpu = [None] * number_of_datasets</span>
    <span class="c1">#     adjust_coef_pinned = [None] * number_of_datasets_back</span>
    <span class="c1">#     fov_cut_matrix_cutted_gpu = [None] * number_of_datasets_back</span>
    <span class="c1">#     fov_cut_matrix_cut = [None] * number_of_datasets</span>
    <span class="c1">#     # fov_cut_matrix_gpu = [None] * number_of_datasets</span>
    <span class="c1">#     sum_vor_pinned = [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     distance_to_center_plane_cut = [None] * number_of_datasets</span>
    <span class="c1">#     distance_to_center_plane_gpu_cut = [None] * number_of_datasets</span>
    <span class="c1">#     distance_to_center_plane_normal_cut = [None] * number_of_datasets</span>
    <span class="c1">#     distance_to_center_plane_normal_gpu_cut = [None] * number_of_datasets</span>
    <span class="c1">#</span>
    <span class="c1">#     # Streams and Events creation</span>
    <span class="c1">#     for dataset in range(number_of_datasets):</span>
    <span class="c1">#         stream.append(cuda.Stream())</span>
    <span class="c1">#         event.append(dict([(marker_names[l], cuda.Event()) for l in range(len(marker_names))]))</span>
    <span class="c1">#</span>
    <span class="c1">#     # Foward Projection Memory Allocation</span>
    <span class="c1">#     # Variables that need an unique alocation</span>
    <span class="c1">#     # A_shappened = np.ascontiguousarray(A.reshape(A.shape[0]*A.shape[1]*A.shape[2]), dtype=np.int32)</span>
    <span class="c1">#     # B_shappened = np.ascontiguousarray(B.reshape(B.shape[0]*B.shape[1]*B.shape[2]), dtype=np.int32)</span>
    <span class="c1">#     # C_shappened = np.ascontiguousarray(C.reshape(C.shape[0]*C.shape[1]*C.shape[2]), dtype=np.int32)</span>
    <span class="c1">#     im_shappened = np.ascontiguousarray(im.reshape(im.shape[0] * im.shape[1] * im.shape[2]), dtype=np.float32)</span>
    <span class="c1">#     fov_cut_matrix_shappened = np.ascontiguousarray(</span>
    <span class="c1">#         fov_cut_matrix.reshape(fov_cut_matrix.shape[0] * fov_cut_matrix.shape[1] * fov_cut_matrix.shape[2]),</span>
    <span class="c1">#         dtype=np.byte)</span>
    <span class="c1">#</span>
    <span class="c1">#     # forward_projection_arrays_page_locked_memory_allocations = [A_gpu, B_gpu, C_gpu, im_gpu]</span>
    <span class="c1">#</span>
    <span class="c1">#     # A_gpu = cuda.mem_alloc(A_shappened.size * A_shappened.dtype.itemsize)</span>
    <span class="c1">#     # B_gpu = cuda.mem_alloc(B_shappened.size * B_shappened.dtype.itemsize)</span>
    <span class="c1">#     # C_gpu = cuda.mem_alloc(C_shappened.size * C_shappened.dtype.itemsize)</span>
    <span class="c1">#     im_gpu = cuda.mem_alloc(im_shappened.size * im_shappened.dtype.itemsize)</span>
    <span class="c1">#     fov_cut_matrix_gpu = cuda.mem_alloc(fov_cut_matrix_shappened.size * fov_cut_matrix_shappened.dtype.itemsize)</span>
    <span class="c1">#     # texref = mod_forward_projection_shared_mem.get_texref(&#39;tex&#39;)</span>
    <span class="c1">#     # texref.set_address(fov_cut_matrix_gpu, fov_cut_matrix_shappened.size * fov_cut_matrix_shappened.dtype.itemsize)</span>
    <span class="c1">#     # # texref.set_format(cuda.array_format.UNSIGNED_INT8, 1)</span>
    <span class="c1">#</span>
    <span class="c1">#     # cuda.memcpy_htod_async(A_gpu, A_shappened)</span>
    <span class="c1">#     # cuda.memcpy_htod_async(B_gpu, B_shappened)</span>
    <span class="c1">#     # cuda.memcpy_htod_async(C_gpu, C_shappened)</span>
    <span class="c1">#     cuda.memcpy_htod_async(im_gpu, im_shappened)</span>
    <span class="c1">#     cuda.memcpy_htod_async(fov_cut_matrix_gpu, fov_cut_matrix_shappened)</span>
    <span class="c1">#</span>
    <span class="c1">#     a_gpu = cuda.mem_alloc(a.size * a.dtype.itemsize)</span>
    <span class="c1">#     b_gpu = cuda.mem_alloc(b.size * b.dtype.itemsize)</span>
    <span class="c1">#     c_gpu = cuda.mem_alloc(c.size * c.dtype.itemsize)</span>
    <span class="c1">#     d_gpu = cuda.mem_alloc(d.size * d.dtype.itemsize)</span>
    <span class="c1">#     a_normal_gpu = cuda.mem_alloc(a_normal.size * a_normal.dtype.itemsize)</span>
    <span class="c1">#     b_normal_gpu = cuda.mem_alloc(b_normal.size * b_normal.dtype.itemsize)</span>
    <span class="c1">#     c_normal_gpu = cuda.mem_alloc(c_normal.size * c_normal.dtype.itemsize)</span>
    <span class="c1">#     d_normal_gpu = cuda.mem_alloc(d_normal.size * d_normal.dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#     a_cf_gpu = cuda.mem_alloc(a_cf.size * a_cf.dtype.itemsize)</span>
    <span class="c1">#     b_cf_gpu = cuda.mem_alloc(b_cf.size * b_cf.dtype.itemsize)</span>
    <span class="c1">#     c_cf_gpu = cuda.mem_alloc(c_cf.size * c_cf.dtype.itemsize)</span>
    <span class="c1">#     d_cf_gpu = cuda.mem_alloc(d_cf.size * d_cf.dtype.itemsize)</span>
    <span class="c1">#     sum_vor_t_gpu = cuda.mem_alloc(sum_vor.size * sum_vor.dtype.itemsize)</span>
    <span class="c1">#     distance_to_center_plane_gpu = cuda.mem_alloc(</span>
    <span class="c1">#         self.distance_to_center_plane.size * self.distance_to_center_plane.dtype.itemsize)</span>
    <span class="c1">#     distance_to_center_plane_normal_gpu = cuda.mem_alloc(</span>
    <span class="c1">#         self.distance_to_center_plane_normal.size * self.distance_to_center_plane_normal.dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#     time_factor_gpu = cuda.mem_alloc(time_factor.size * time_factor.dtype.itemsize)</span>
    <span class="c1">#     # Transfer memory to Optimizer</span>
    <span class="c1">#     cuda.memcpy_htod_async(a_gpu, a)</span>
    <span class="c1">#     cuda.memcpy_htod_async(b_gpu, b)</span>
    <span class="c1">#     cuda.memcpy_htod_async(c_gpu, c)</span>
    <span class="c1">#     cuda.memcpy_htod_async(d_gpu, d)</span>
    <span class="c1">#     cuda.memcpy_htod_async(a_normal_gpu, a_normal)</span>
    <span class="c1">#     cuda.memcpy_htod_async(b_normal_gpu, b_normal)</span>
    <span class="c1">#     cuda.memcpy_htod_async(c_normal_gpu, c_normal)</span>
    <span class="c1">#     cuda.memcpy_htod_async(d_normal_gpu, d_normal)</span>
    <span class="c1">#</span>
    <span class="c1">#     cuda.memcpy_htod_async(a_cf_gpu, a_cf)</span>
    <span class="c1">#     cuda.memcpy_htod_async(b_cf_gpu, b_cf)</span>
    <span class="c1">#     cuda.memcpy_htod_async(c_cf_gpu, c_cf)</span>
    <span class="c1">#     cuda.memcpy_htod_async(d_cf_gpu, d_cf)</span>
    <span class="c1">#     cuda.memcpy_htod_async(time_factor_gpu, time_factor)</span>
    <span class="c1">#     cuda.memcpy_htod_async(distance_to_center_plane_gpu, self.distance_to_center_plane)</span>
    <span class="c1">#     cuda.memcpy_htod_async(distance_to_center_plane_normal_gpu, self.distance_to_center_plane_normal)</span>
    <span class="c1">#</span>
    <span class="c1">#     for dataset in range(number_of_datasets):</span>
    <span class="c1">#         # if dataset == number_of_datasets:</span>
    <span class="c1">#         #     begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
    <span class="c1">#         #     end_dataset = number_of_events</span>
    <span class="c1">#         #     adjust_coef_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#         #         adjust_coef[int(np.floor(im_cut_dim[0] * dataset)):adjust_coef.shape[0],</span>
    <span class="c1">#         #         int(np.floor(im_cut_dim[1] * dataset)):adjust_coef.shape[1],</span>
    <span class="c1">#         #         int(np.floor(im_cut_dim[2] * dataset)):adjust_coef.shape[2]],</span>
    <span class="c1">#         #         dtype=np.float32)</span>
    <span class="c1">#         #     fov_cut_matrix_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#         #         fov_cut_matrix[int(np.floor(im_cut_dim[0] * dataset)):fov_cut_matrix.shape[0],</span>
    <span class="c1">#         #         int(np.floor(im_cut_dim[1] * dataset)):fov_cut_matrix.shape[1],</span>
    <span class="c1">#         #         int(np.floor(im_cut_dim[2] * dataset)):fov_cut_matrix.shape[2]],</span>
    <span class="c1">#         #         dtype=np.float32)</span>
    <span class="c1">#         # else:</span>
    <span class="c1">#         begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
    <span class="c1">#         end_dataset = np.int32((dataset + 1) * number_of_events / number_of_datasets)</span>
    <span class="c1">#</span>
    <span class="c1">#         # Cutting dataset</span>
    <span class="c1">#         # For forward projection the data is cutted by number of events. For backprojection is cutted per image pieces of image</span>
    <span class="c1">#         a_cut[dataset] = a[begin_dataset:end_dataset]</span>
    <span class="c1">#         b_cut[dataset] = b[begin_dataset:end_dataset]</span>
    <span class="c1">#         c_cut[dataset] = c[begin_dataset:end_dataset]</span>
    <span class="c1">#         d_cut[dataset] = d[begin_dataset:end_dataset]</span>
    <span class="c1">#         a_normal_cut[dataset] = a_normal[begin_dataset:end_dataset]</span>
    <span class="c1">#         b_normal_cut[dataset] = b_normal[begin_dataset:end_dataset]</span>
    <span class="c1">#         c_normal_cut[dataset] = c_normal[begin_dataset:end_dataset]</span>
    <span class="c1">#         d_normal_cut[dataset] = d_normal[begin_dataset:end_dataset]</span>
    <span class="c1">#</span>
    <span class="c1">#         a_cf_cut[dataset] = a_cf[begin_dataset:end_dataset]</span>
    <span class="c1">#         b_cf_cut[dataset] = b_cf[begin_dataset:end_dataset]</span>
    <span class="c1">#         c_cf_cut[dataset] = c_cf[begin_dataset:end_dataset]</span>
    <span class="c1">#         d_cf_cut[dataset] = d_cf[begin_dataset:end_dataset]</span>
    <span class="c1">#         sum_vor_cut[dataset] = sum_vor[begin_dataset:end_dataset]</span>
    <span class="c1">#         distance_to_center_plane_cut[dataset] = self.distance_to_center_plane[begin_dataset:end_dataset]</span>
    <span class="c1">#         distance_to_center_plane_normal_cut[dataset] = self.distance_to_center_plane_normal[</span>
    <span class="c1">#                                                        begin_dataset:end_dataset]</span>
    <span class="c1">#</span>
    <span class="c1">#         # Forward</span>
    <span class="c1">#         a_cut_gpu[dataset] = cuda.mem_alloc(a_cut[dataset].size * a_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         b_cut_gpu[dataset] = cuda.mem_alloc(b_cut[dataset].size * b_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         c_cut_gpu[dataset] = cuda.mem_alloc(c_cut[dataset].size * c_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         d_cut_gpu[dataset] = cuda.mem_alloc(d_cut[dataset].size * d_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         a_cut_normal_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             a_normal_cut[dataset].size * a_normal_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         b_cut_normal_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             b_normal_cut[dataset].size * b_normal_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         c_cut_normal_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             c_normal_cut[dataset].size * c_normal_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         d_cut_normal_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             d_normal_cut[dataset].size * d_normal_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         a_cf_cut_gpu[dataset] = cuda.mem_alloc(a_cf_cut[dataset].size * a_cf_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         b_cf_cut_gpu[dataset] = cuda.mem_alloc(b_cf_cut[dataset].size * b_cf_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         c_cf_cut_gpu[dataset] = cuda.mem_alloc(c_cf_cut[dataset].size * c_cf_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         d_cf_cut_gpu[dataset] = cuda.mem_alloc(d_cf_cut[dataset].size * d_cf_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         distance_to_center_plane_gpu_cut[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             distance_to_center_plane_cut[dataset].size * distance_to_center_plane_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#         distance_to_center_plane_normal_gpu_cut[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             distance_to_center_plane_normal_cut[dataset].size * distance_to_center_plane_normal_cut[</span>
    <span class="c1">#                 dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         sum_vor_gpu[dataset] = cuda.mem_alloc(sum_vor_cut[dataset].size * sum_vor_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         sum_vor_pinned[dataset] = cuda.register_host_memory(sum_vor_cut[dataset])</span>
    <span class="c1">#         assert np.all(sum_vor_pinned[dataset] == sum_vor_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(sum_vor_gpu[dataset], sum_vor_pinned[dataset], stream[dataset])</span>
    <span class="c1">#         # sum_vor_gpu[dataset] = np.intp(x.base.get_device_pointer())</span>
    <span class="c1">#         # cuda.memcpy_htod_async(probability_gpu[dataset], probability_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(a_cut_gpu[dataset], a_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(b_cut_gpu[dataset], b_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(c_cut_gpu[dataset], c_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(d_cut_gpu[dataset], d_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(a_cut_normal_gpu[dataset], a_normal_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(b_cut_normal_gpu[dataset], b_normal_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(c_cut_normal_gpu[dataset], c_normal_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(d_cut_normal_gpu[dataset], d_normal_cut[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#         cuda.memcpy_htod_async(a_cf_cut_gpu[dataset], a_cf_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(b_cf_cut_gpu[dataset], b_cf_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(c_cf_cut_gpu[dataset], c_cf_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(d_cf_cut_gpu[dataset], d_cf_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(distance_to_center_plane_gpu_cut[dataset], distance_to_center_plane_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(distance_to_center_plane_normal_gpu_cut[dataset],</span>
    <span class="c1">#                                distance_to_center_plane_normal_cut[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#     adjust_coef = np.ascontiguousarray(adjust_coef.reshape(</span>
    <span class="c1">#         adjust_coef.shape[0] * adjust_coef.shape[1] * adjust_coef.shape[2]),</span>
    <span class="c1">#         dtype=np.float32)</span>
    <span class="c1">#     # fov_cut_matrix = np.ascontiguousarray(fov_cut_matrix.reshape(</span>
    <span class="c1">#     #     fov_cut_matrix.shape[0] * fov_cut_matrix.shape[1] * fov_cut_matrix.shape[2]),</span>
    <span class="c1">#     #     dtype=np.float32)</span>
    <span class="c1">#     A = np.ascontiguousarray(A.reshape(</span>
    <span class="c1">#         A.shape[0] * A.shape[1] * A.shape[2]),</span>
    <span class="c1">#         dtype=np.short)</span>
    <span class="c1">#     B = np.ascontiguousarray(B.reshape(</span>
    <span class="c1">#         B.shape[0] * B.shape[1] * B.shape[2]),</span>
    <span class="c1">#         dtype=np.short)</span>
    <span class="c1">#     C = np.ascontiguousarray(C.reshape(</span>
    <span class="c1">#         C.shape[0] * C.shape[1] * C.shape[2]),</span>
    <span class="c1">#         dtype=np.short)</span>
    <span class="c1">#</span>
    <span class="c1">#     # ---- Divide into datasets variables backprojection</span>
    <span class="c1">#     for dataset in range(number_of_datasets_back):</span>
    <span class="c1">#         voxels_division = adjust_coef.shape[0] // number_of_datasets_back</span>
    <span class="c1">#         adjust_coef_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#             adjust_coef[dataset * voxels_division:(dataset + 1) * voxels_division],</span>
    <span class="c1">#             dtype=np.float32)</span>
    <span class="c1">#</span>
    <span class="c1">#         fov_cut_matrix_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#             fov_cut_matrix_shappened[dataset * voxels_division:(dataset + 1) * voxels_division],</span>
    <span class="c1">#             dtype=np.byte)</span>
    <span class="c1">#</span>
    <span class="c1">#         A_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#             A[dataset * voxels_division:(dataset + 1) * voxels_division],</span>
    <span class="c1">#             dtype=np.short)</span>
    <span class="c1">#</span>
    <span class="c1">#         B_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#             B[dataset * voxels_division:(dataset + 1) * voxels_division],</span>
    <span class="c1">#             dtype=np.short)</span>
    <span class="c1">#</span>
    <span class="c1">#         C_cut[dataset] = np.ascontiguousarray(</span>
    <span class="c1">#             C[dataset * voxels_division:(dataset + 1) * voxels_division],</span>
    <span class="c1">#             dtype=np.short)</span>
    <span class="c1">#         # Backprojection</span>
    <span class="c1">#         adjust_coef_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             adjust_coef_cut[dataset].size * adjust_coef_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         adjust_coef_pinned[dataset] = cuda.register_host_memory(adjust_coef_cut[dataset])</span>
    <span class="c1">#         assert np.all(adjust_coef_pinned[dataset] == adjust_coef_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(adjust_coef_gpu[dataset], adjust_coef_pinned[dataset], stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#         fov_cut_matrix_cutted_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             fov_cut_matrix_cut[dataset].size * fov_cut_matrix_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         A_cut_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             A_cut[dataset].size * A_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         B_cut_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             B_cut[dataset].size * B_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         C_cut_gpu[dataset] = cuda.mem_alloc(</span>
    <span class="c1">#             C_cut[dataset].size * C_cut[dataset].dtype.itemsize)</span>
    <span class="c1">#</span>
    <span class="c1">#         cuda.memcpy_htod_async(adjust_coef_gpu[dataset], adjust_coef_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(fov_cut_matrix_cutted_gpu[dataset], fov_cut_matrix_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(A_cut_gpu[dataset], A_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(B_cut_gpu[dataset], B_cut[dataset])</span>
    <span class="c1">#         cuda.memcpy_htod_async(C_cut_gpu[dataset], C_cut[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#     free, total = cuda.mem_get_info()</span>
    <span class="c1">#</span>
    <span class="c1">#     print(&#39;%.1f %% of device memory is free.&#39; % ((free / float(total)) * 100))</span>
    <span class="c1">#</span>
    <span class="c1">#     # -------------OSEM---------</span>
    <span class="c1">#     it = self.number_of_iterations</span>
    <span class="c1">#     subsets = self.number_of_subsets</span>
    <span class="c1">#     print(&#39;Number events for reconstruction: {}&#39;.format(number_of_events))</span>
    <span class="c1">#</span>
    <span class="c1">#     im = np.ascontiguousarray(im.reshape(im.shape[0] * im.shape[1] * im.shape[2]), dtype=np.float32)</span>
    <span class="c1">#     for i in range(it):</span>
    <span class="c1">#         print(&#39;Iteration number: {}\n----------------&#39;.format(i + 1))</span>
    <span class="c1">#         begin_event = np.int32(0)</span>
    <span class="c1">#         end_event = np.int32(number_of_events / subsets)</span>
    <span class="c1">#         for sb in range(subsets):</span>
    <span class="c1">#             print(&#39;Subset number: {}&#39;.format(sb))</span>
    <span class="c1">#             number_of_events_subset = np.int32(end_event - begin_event)</span>
    <span class="c1">#             tic = time.time()</span>
    <span class="c1">#             # Cycle forward Projection</span>
    <span class="c1">#             for dataset in range(number_of_datasets):</span>
    <span class="c1">#</span>
    <span class="c1">#                 if dataset == number_of_datasets:</span>
    <span class="c1">#                     begin_dataset = np.int32(dataset * number_of_events_subset / number_of_datasets)</span>
    <span class="c1">#                     end_dataset = number_of_events_subset</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     begin_dataset = np.int32(dataset * number_of_events_subset / number_of_datasets)</span>
    <span class="c1">#                     end_dataset = np.int32((dataset + 1) * number_of_events_subset / number_of_datasets)</span>
    <span class="c1">#</span>
    <span class="c1">#                 threadsperblock = (256, 1, 1)</span>
    <span class="c1">#                 blockspergrid_x = int(math.ceil(((end_dataset - begin_dataset)) / threadsperblock[0]))</span>
    <span class="c1">#                 blockspergrid_y = int(math.ceil(1 / threadsperblock[1]))</span>
    <span class="c1">#                 blockspergrid_z = int(math.ceil(1 / threadsperblock[2]))</span>
    <span class="c1">#                 blockspergrid = (blockspergrid_x, blockspergrid_y, blockspergrid_z)</span>
    <span class="c1">#                 event[dataset][&#39;kernel_begin&#39;].record(stream[dataset])</span>
    <span class="c1">#                 # depth = np.int32(5)</span>
    <span class="c1">#                 # weight = np.int32(A.shape[2]/2)</span>
    <span class="c1">#                 # height = np.int32(A.shape[2]/2)</span>
    <span class="c1">#                 if self.cdrf:</span>
    <span class="c1">#                     func_forward = mod_forward_projection_shared_mem_cdrf.get_function(&quot;forward_projection_cdrf&quot;)</span>
    <span class="c1">#                     func_forward(weight, height, depth, start_x, start_y, start_z,</span>
    <span class="c1">#                                  distance_to_center_plane_normal_gpu_cut[dataset],</span>
    <span class="c1">#                                  distance_to_center_plane_gpu_cut[dataset],</span>
    <span class="c1">#                                  half_distance_between_array_pixel,</span>
    <span class="c1">#                                  number_of_events, begin_dataset, end_dataset, a_cut_gpu[dataset],</span>
    <span class="c1">#                                  a_cut_normal_gpu[dataset], a_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  b_cut_gpu[dataset], b_cut_normal_gpu[dataset], b_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  c_cut_gpu[dataset], c_cut_normal_gpu[dataset],</span>
    <span class="c1">#                                  c_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  d_cut_gpu[dataset],</span>
    <span class="c1">#                                  d_cut_normal_gpu[dataset], d_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  sum_vor_gpu[dataset], fov_cut_matrix_gpu, im_gpu,</span>
    <span class="c1">#                                  block=threadsperblock,</span>
    <span class="c1">#                                  grid=blockspergrid,</span>
    <span class="c1">#                                  stream=stream[dataset])</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     func_forward = mod_forward_projection_shared_mem.get_function(&quot;forward_projection&quot;)</span>
    <span class="c1">#                     func_forward(weight, height, depth, start_x, start_y, start_z, half_crystal_pitch_xy,</span>
    <span class="c1">#                                  half_crystal_pitch_z,</span>
    <span class="c1">#                                  half_distance_between_array_pixel,</span>
    <span class="c1">#                                  number_of_events, begin_dataset, end_dataset, a_cut_gpu[dataset],</span>
    <span class="c1">#                                  a_cut_normal_gpu[dataset], a_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  b_cut_gpu[dataset], b_cut_normal_gpu[dataset], b_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  c_cut_gpu[dataset], c_cut_normal_gpu[dataset],</span>
    <span class="c1">#                                  c_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  d_cut_gpu[dataset],</span>
    <span class="c1">#                                  d_cut_normal_gpu[dataset], d_cf_cut_gpu[dataset],</span>
    <span class="c1">#                                  sum_vor_gpu[dataset], fov_cut_matrix_gpu, im_gpu,</span>
    <span class="c1">#                                  block=threadsperblock,</span>
    <span class="c1">#                                  grid=blockspergrid,</span>
    <span class="c1">#                                  stream=stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#             # Sincronization of streams</span>
    <span class="c1">#             for dataset in range(number_of_datasets):  # Commenting out this line should break concurrency.</span>
    <span class="c1">#                 event[dataset][&#39;kernel_end&#39;].record(stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#             # Transfering data from Optimizer</span>
    <span class="c1">#             for dataset in range(number_of_datasets):</span>
    <span class="c1">#                 begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
    <span class="c1">#                 end_dataset = np.int32((dataset + 1) * number_of_events / number_of_datasets)</span>
    <span class="c1">#                 # cuda.memcpy_dtoh_async(, sum_vor_gpu[dataset])</span>
    <span class="c1">#                 cuda.memcpy_dtoh_async(sum_vor_pinned[dataset], sum_vor_gpu[dataset], stream[dataset])</span>
    <span class="c1">#                 sum_vor[begin_dataset:end_dataset] = sum_vor_pinned[dataset]</span>
    <span class="c1">#                 # cuda.cudaStream.Synchronize(stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#                 toc = time.time()</span>
    <span class="c1">#</span>
    <span class="c1">#             cuda.Context.synchronize()</span>
    <span class="c1">#</span>
    <span class="c1">#             print(&#39;Time part Forward Projection {} : {}&#39;.format(1, toc - tic))</span>
    <span class="c1">#             # number_of_datasets = np.int32(2)</span>
    <span class="c1">#             # teste = np.copy(sum_vor)</span>
    <span class="c1">#             # # sum_vor[sum_vor&lt;1]=0</span>
    <span class="c1">#             # sum_vor = np.ascontiguousarray(teste, dtype=np.float32)</span>
    <span class="c1">#             # sum_vor=np.ascontiguousarray(np.ones((self.a.shape)), dtype=np.float32)</span>
    <span class="c1">#             print(&#39;SUM VOR: {}&#39;.format(np.sum(sum_vor)))</span>
    <span class="c1">#             # cuda.memcpy_htod_async(sum_vor_t_gpu, sum_vor)</span>
    <span class="c1">#</span>
    <span class="c1">#             cuda.memcpy_htod_async(sum_vor_t_gpu, sum_vor)</span>
    <span class="c1">#</span>
    <span class="c1">#             # ------------BACKPROJECTION-----------</span>
    <span class="c1">#</span>
    <span class="c1">#             for dataset in range(number_of_datasets_back):</span>
    <span class="c1">#                 dataset = np.int32(dataset)</span>
    <span class="c1">#                 begin_dataset = np.int32(0)</span>
    <span class="c1">#                 end_dataset = np.int32(number_of_events_subset)</span>
    <span class="c1">#</span>
    <span class="c1">#                 # begin_dataset = np.int32(0)</span>
    <span class="c1">#                 # end_dataset = np.int32(number_of_events)</span>
    <span class="c1">#</span>
    <span class="c1">#                 event[dataset][&#39;kernel_begin&#39;].record(stream[dataset])</span>
    <span class="c1">#                 # weight_cutted, height_cutted, depth_cutted = np.int32(adjust_coef_cut[dataset].shape[0]), np.int32(</span>
    <span class="c1">#                 #     adjust_coef_cut[dataset].shape[1]), np.int32(adjust_coef_cut[dataset].shape[2])</span>
    <span class="c1">#                 weight_cutted, height_cutted, depth_cutted = np.int32(adjust_coef_cut[dataset].shape[0]), np.int32(</span>
    <span class="c1">#                     1), np.int32(1)</span>
    <span class="c1">#</span>
    <span class="c1">#                 number_of_voxels_thread = 128</span>
    <span class="c1">#                 threadsperblock = (np.int(number_of_voxels_thread), 1, 1)</span>
    <span class="c1">#                 blockspergrid_x = int(math.ceil(adjust_coef_cut[dataset].shape[0] / threadsperblock[0]))</span>
    <span class="c1">#                 blockspergrid_y = int(math.ceil(1 / threadsperblock[1]))</span>
    <span class="c1">#                 blockspergrid_z = int(math.ceil(1 / threadsperblock[2]))</span>
    <span class="c1">#                 # blockspergrid_y = int(math.ceil(adjust_coef_cut[dataset].shape[1] / threadsperblock[1]))</span>
    <span class="c1">#                 # blockspergrid_z = int(math.ceil(adjust_coef_cut[dataset].shape[2] / threadsperblock[2]))</span>
    <span class="c1">#                 blockspergrid = (blockspergrid_x, blockspergrid_y, blockspergrid_z)</span>
    <span class="c1">#                 shared_memory = threadsperblock[0] * threadsperblock[1] * threadsperblock[2] * 4</span>
    <span class="c1">#                 if self.cdrf:</span>
    <span class="c1">#                     if self.normalization_calculation_flag:</span>
    <span class="c1">#                         func_backward = mod_normalization_shared_mem_cdrf.get_function(&quot;normalization_cdrf&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                     else:</span>
    <span class="c1">#                         func_backward = mod_backward_projection_shared_mem_cdrf.get_function(&quot;backprojection_cdrf&quot;)</span>
    <span class="c1">#                     func_backward(dataset, weight_cutted, height_cutted, depth_cutted,</span>
    <span class="c1">#                                   distance_to_center_plane_normal_gpu,</span>
    <span class="c1">#                                   distance_to_center_plane_gpu, half_distance_between_array_pixel,</span>
    <span class="c1">#                                   number_of_events, begin_dataset, end_dataset, a_gpu, a_normal_gpu, a_cf_gpu,</span>
    <span class="c1">#                                   b_gpu, b_normal_gpu, b_cf_gpu, c_gpu, c_normal_gpu, c_cf_gpu, d_gpu,</span>
    <span class="c1">#                                   d_normal_gpu, d_cf_gpu, A_cut_gpu[dataset], B_cut_gpu[dataset],</span>
    <span class="c1">#                                   C_cut_gpu[dataset],</span>
    <span class="c1">#                                   adjust_coef_gpu[dataset],</span>
    <span class="c1">#                                   sum_vor_t_gpu, fov_cut_matrix_cutted_gpu[dataset], time_factor_gpu,</span>
    <span class="c1">#                                   block=threadsperblock,</span>
    <span class="c1">#                                   grid=blockspergrid,</span>
    <span class="c1">#                                   shared=np.int(4 * number_of_voxels_thread),</span>
    <span class="c1">#                                   stream=stream[dataset],</span>
    <span class="c1">#                                   )</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     if self.normalization_calculation_flag:</span>
    <span class="c1">#                         func_backward = mod_normalization_shared_mem.get_function(&quot;normalization&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#                     else:</span>
    <span class="c1">#                         func_backward = mod_backward_projection_shared_mem.get_function(&quot;backprojection&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#                     func_backward(dataset, weight_cutted, height_cutted, depth_cutted, half_crystal_pitch_xy,</span>
    <span class="c1">#                                   half_crystal_pitch_z, half_distance_between_array_pixel,</span>
    <span class="c1">#                                   number_of_events, begin_dataset, end_dataset, a_gpu, a_normal_gpu, a_cf_gpu,</span>
    <span class="c1">#                                   b_gpu, b_normal_gpu, b_cf_gpu, c_gpu, c_normal_gpu, c_cf_gpu, d_gpu,</span>
    <span class="c1">#                                   d_normal_gpu, d_cf_gpu, A_cut_gpu[dataset], B_cut_gpu[dataset],</span>
    <span class="c1">#                                   C_cut_gpu[dataset],</span>
    <span class="c1">#                                   adjust_coef_gpu[dataset],</span>
    <span class="c1">#                                   sum_vor_t_gpu, fov_cut_matrix_cutted_gpu[dataset], time_factor_gpu,</span>
    <span class="c1">#                                   block=threadsperblock,</span>
    <span class="c1">#                                   grid=blockspergrid,</span>
    <span class="c1">#                                   shared=np.int(4 * number_of_voxels_thread),</span>
    <span class="c1">#                                   stream=stream[dataset],</span>
    <span class="c1">#                                   )</span>
    <span class="c1">#</span>
    <span class="c1">#             for dataset in range(number_of_datasets_back):  # Commenting out this line should break concurrency.</span>
    <span class="c1">#                 event[dataset][&#39;kernel_end&#39;].record(stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#             for dataset in range(number_of_datasets_back):</span>
    <span class="c1">#                 cuda.memcpy_dtoh_async(adjust_coef_cut[dataset], adjust_coef_gpu[dataset])</span>
    <span class="c1">#                 adjust_coef[dataset * voxels_division:(dataset + 1) * voxels_division] = adjust_coef_cut[dataset]</span>
    <span class="c1">#</span>
    <span class="c1">#             cuda.Context.synchronize()</span>
    <span class="c1">#             print(&#39;Time part Backward Projection {} : {}&#39;.format(1, time.time() - toc))</span>
    <span class="c1">#</span>
    <span class="c1">#             # Image Normalization</span>
    <span class="c1">#             # if i ==0:</span>
    <span class="c1">#             #     norm_im=np.copy(adjust_coef)</span>
    <span class="c1">#             #     norm_im=norm_im/np.max(norm_im)</span>
    <span class="c1">#             #     norm_im[norm_im == 0] = np.min(norm_im[np.nonzero(norm_im)])</span>
    <span class="c1">#             # normalization_matrix = gaussian_filter(normalization_matrix, 0.5)</span>
    <span class="c1">#</span>
    <span class="c1">#             # im_med = np.load(&quot;C:\\Users\\pedro.encarnacao\\OneDrive - Universidade de Aveiro\\PhD\\Reconstruo\\NAF+FDG\\Easypet Scan 05 Aug 2019 - 14h 36m 33s\\static_image\\Easypet Scan 05 Aug 2019 - 14h 36m 33s mlem.npy&quot;)</span>
    <span class="c1">#             # self.algorithm = &quot;LM-MRP&quot;</span>
    <span class="c1">#             if self.algorithm == &quot;LM-MRP&quot;:</span>
    <span class="c1">#                 beta = self.algorithm_options[0]</span>
    <span class="c1">#                 kernel_filter_size = self.algorithm_options[1]</span>
    <span class="c1">#                 im_to_filter = im.reshape(weight, height, depth)</span>
    <span class="c1">#                 im_med = median_filter(im_to_filter, kernel_filter_size)</span>
    <span class="c1">#                 penalized_term = np.copy(im_to_filter)</span>
    <span class="c1">#                 penalized_term[im_med != 0] = 1 + beta * (im_to_filter[im_med != 0] - im_med[im_med != 0]) / im_med[</span>
    <span class="c1">#                     im_med != 0]</span>
    <span class="c1">#                 penalized_term = np.ascontiguousarray(penalized_term.reshape(weight * height * depth),</span>
    <span class="c1">#                                                       dtype=np.float32)</span>
    <span class="c1">#                 # penalized_term = np.ascontiguousarray(penalized_term, dtype=np.float32)</span>
    <span class="c1">#</span>
    <span class="c1">#             if self.algorithm == &quot;MAP&quot;:</span>
    <span class="c1">#                 beta = 0.5</span>
    <span class="c1">#                 im_map = np.load(</span>
    <span class="c1">#                     &quot;C:\\Users\\pedro.encarnacao\\OneDrive - Universidade de Aveiro\\PhD\\Reconstruo\\NAF+FDG\\Easypet Scan 05 Aug 2019 - 14h 36m 33s\\static_image\\Easypet Scan 05 Aug 2019 - 14h 36m 33s mlem.npy&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#             im[normalization_matrix != 0] = im[normalization_matrix != 0] * adjust_coef[</span>
    <span class="c1">#                 normalization_matrix != 0] / (normalization_matrix[normalization_matrix != 0])</span>
    <span class="c1">#             im[normalization_matrix == 0] = 0</span>
    <span class="c1">#             if self.algorithm == &quot;LM-MRP&quot;:</span>
    <span class="c1">#                 im[penalized_term != 0] = im[penalized_term != 0] / penalized_term[penalized_term != 0]</span>
    <span class="c1">#             # im = fourier_gaussian(im, sigma=0.2)</span>
    <span class="c1">#             # im = gaussian_filter(im, 0.4)</span>
    <span class="c1">#             print(&#39;SUM IMAGE: {}&#39;.format(np.sum(im)))</span>
    <span class="c1">#             im = np.ascontiguousarray(im, dtype=np.float32)</span>
    <span class="c1">#             # im = im * adjust_coef / sensivity_matrix[np.nonzero(sensivity_matrix)]</span>
    <span class="c1">#             cuda.memcpy_htod_async(im_gpu, im)</span>
    <span class="c1">#</span>
    <span class="c1">#             # Clearing variables</span>
    <span class="c1">#             sum_vor = np.ascontiguousarray(</span>
    <span class="c1">#                 np.zeros(self.a.shape, dtype=np.float32))</span>
    <span class="c1">#</span>
    <span class="c1">#             adjust_coef = np.ascontiguousarray(</span>
    <span class="c1">#                 np.zeros((self.number_of_pixels_x * self.number_of_pixels_y * self.number_of_pixels_z),</span>
    <span class="c1">#                          dtype=np.float32))</span>
    <span class="c1">#</span>
    <span class="c1">#             for dataset in range(number_of_datasets):</span>
    <span class="c1">#                 # if dataset == number_of_datasets:</span>
    <span class="c1">#                 #     begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
    <span class="c1">#                 #     end_dataset = number_of_events</span>
    <span class="c1">#                 #</span>
    <span class="c1">#                 # else:</span>
    <span class="c1">#                 begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
    <span class="c1">#                 end_dataset = np.int32((dataset + 1) * number_of_events / number_of_datasets)</span>
    <span class="c1">#                 # adjust_coef_cut[dataset] = np.ascontiguousarray(adjust_coef[:, :,</span>
    <span class="c1">#                 #                                                 int(np.floor(im_cut_dim[2] * dataset)):int(</span>
    <span class="c1">#                 #                                                     np.floor(im_cut_dim[2] * (dataset + 1)))],</span>
    <span class="c1">#                 #                                                 dtype=np.float32)</span>
    <span class="c1">#</span>
    <span class="c1">#                 sum_vor_cut[dataset] = sum_vor[begin_dataset:end_dataset]</span>
    <span class="c1">#                 # cuda.memcpy_htod_async(sum_vor_gpu[dataset], sum_vor_cut[dataset])</span>
    <span class="c1">#                 sum_vor_pinned[dataset] = cuda.register_host_memory(sum_vor_cut[dataset])</span>
    <span class="c1">#                 assert np.all(sum_vor_pinned[dataset] == sum_vor_cut[dataset])</span>
    <span class="c1">#                 cuda.memcpy_htod_async(sum_vor_gpu[dataset], sum_vor_pinned[dataset], stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#             for dataset in range(number_of_datasets_back):</span>
    <span class="c1">#                 adjust_coef_cut[dataset] = adjust_coef[dataset * voxels_division:(dataset + 1) * voxels_division]</span>
    <span class="c1">#                 adjust_coef_pinned[dataset] = cuda.register_host_memory(adjust_coef_cut[dataset])</span>
    <span class="c1">#                 assert np.all(adjust_coef_pinned[dataset] == adjust_coef_cut[dataset])</span>
    <span class="c1">#                 cuda.memcpy_htod_async(adjust_coef_gpu[dataset], adjust_coef_pinned[dataset], stream[dataset])</span>
    <span class="c1">#</span>
    <span class="c1">#             if self.saved_image_by_iteration:</span>
    <span class="c1">#                 im = im.reshape(weight, height, depth)</span>
    <span class="c1">#                 self._save_image_by_it(im, i, sb)</span>
    <span class="c1">#</span>
    <span class="c1">#             if self.signals_interface is not None:</span>
    <span class="c1">#                 self.signals_interface.trigger_update_label_reconstruction_status.emit(</span>
    <span class="c1">#                     &quot;{}: Iteration {}&quot;.format(self.current_info_step, i + 1))</span>
    <span class="c1">#                 self.signals_interface.trigger_progress_reconstruction_partial.emit(</span>
    <span class="c1">#                     int(np.round(100 * (i + 1) * (sb + subsets) / (it * subsets), 0)))</span>
    <span class="c1">#</span>
    <span class="c1">#     im = im.reshape(weight, height, depth)</span>
    <span class="c1">#     return im * subsets</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_vor_design_gpu_shared_memory_multiple_reads_DOI</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">a_normal</span><span class="p">,</span> <span class="n">a_cf</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b_normal</span><span class="p">,</span> <span class="n">b_cf</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">c_normal</span><span class="p">,</span>
                                                         <span class="n">c_cf</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
                                                         <span class="n">d</span><span class="p">,</span> <span class="n">d_normal</span><span class="p">,</span> <span class="n">d_cf</span><span class="p">,</span> <span class="n">adjust_coef</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">half_crystal_pitch_xy</span><span class="p">,</span>
                                                         <span class="n">half_crystal_pitch_z</span><span class="p">,</span>
                                                         <span class="n">sum_vor</span><span class="p">,</span> <span class="n">fov_cut_matrix</span><span class="p">,</span> <span class="n">normalization_matrix</span><span class="p">,</span> <span class="n">time_factor</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimizer STARTED - Multiple reads&#39;</span><span class="p">)</span>
        <span class="c1"># cuda.init()</span>
        <span class="n">cuda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cuda_drv</span>
        <span class="c1"># device = cuda.Device(0)  # enter your gpu id here</span>
        <span class="c1"># ctx = device.make_context()</span>
        <span class="n">number_of_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># start_x = np.int32(A[0, 0, 0])</span>
        <span class="n">start_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">start_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">start_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start_point: </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start_x</span><span class="p">,</span> <span class="n">start_y</span><span class="p">,</span> <span class="n">start_z</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Image size: </span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>

        <span class="n">half_distance_between_array_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_between_array_pixel</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">normalization_matrix</span> <span class="o">=</span> <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">normalization_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># SOURCE MODELS (DEVICE CODE)</span>

        <span class="n">mod_forward_projection_shared_mem</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        #include &lt;stdint.h&gt;</span>

<span class="s2">        texture&lt;char, 1&gt; tex;</span>


<span class="s2">        __global__ void forward_projection</span>
<span class="s2">        (const int n, const int m, const int p, const int start_x, const int start_y, const int start_z,</span>
<span class="s2">        const float crystal_pitch_XY,const float crystal_pitch_Z,const float distance_between_array_pixel,</span>
<span class="s2">        int number_of_events, const int begin_event_gpu_limitation,  const int end_event_gpu_limitation, </span>
<span class="s2">        float *a, float *a_normal, float *a_cf, float *b,float *b_normal, float *b_cf,float *c,float *c_normal, </span>
<span class="s2">        float *c_cf, float *d, float *d_normal, float *d_cf, float *sum_vor, const char *fov_cut_matrix, const float *im_old)</span>
<span class="s2">                               {</span>
<span class="s2">                                  const int shared_memory_size = 256;</span>
<span class="s2">                                   __shared__ float a_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float b_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float c_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float d_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float a_normal_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float b_normal_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float c_normal_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float d_normal_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float a_cf_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float b_cf_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float c_cf_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float d_cf_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ float sum_vor_shared[shared_memory_size];</span>
<span class="s2">                                   __shared__ char fov_cut_matrix_shared[shared_memory_size];</span>
<span class="s2">                                   /*</span>
<span class="s2">                                  const int blockId = blockIdx.x+ blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;</span>
<span class="s2">                                  const int threadId= blockId * (blockDim.x * blockDim.y * blockDim.z)+ (threadIdx.z * (blockDim.x * blockDim.y))+ (threadIdx.y * blockDim.x)+ threadIdx.x;</span>
<span class="s2">                                  */</span>
<span class="s2">                                  int threadId=blockIdx.x *blockDim.x + threadIdx.x;</span>
<span class="s2">                                  int e;</span>

<span class="s2">                                  float d2;</span>
<span class="s2">                                  float d2_normal;</span>
<span class="s2">                                  float d2_cf;</span>
<span class="s2">                                  float value;</span>
<span class="s2">                                  float value_normal;</span>
<span class="s2">                                  float value_cf;</span>
<span class="s2">                                  float sum_vor_temp;</span>
<span class="s2">                                  int index;                                  </span>
<span class="s2">                                  int x_t;</span>
<span class="s2">                                  int y_t;</span>
<span class="s2">                                  int z_t;</span>
<span class="s2">                                  float max_distance_projector;     </span>
<span class="s2">                                  const int number_events_max = end_event_gpu_limitation-begin_event_gpu_limitation;</span>
<span class="s2">                                  const float error_pixel = 0.0000f;</span>
<span class="s2">                                   if (threadIdx.x&gt;shared_memory_size)</span>
<span class="s2">                                   {</span>
<span class="s2">                                   return;</span>
<span class="s2">                                   }</span>
<span class="s2">                                   if(threadId&gt;number_events_max)</span>
<span class="s2">                                   {</span>
<span class="s2">                                   return;</span>
<span class="s2">                                   }</span>

<span class="s2">                                  __syncthreads();</span>
<span class="s2">                                  e = threadId;</span>
<span class="s2">                                  int e_m = threadIdx.x;</span>
<span class="s2">                                  a_shared[e_m] = a[e];</span>
<span class="s2">                                  b_shared[e_m] = b[e];</span>
<span class="s2">                                  c_shared[e_m] = c[e];</span>
<span class="s2">                                  d_shared[e_m] = d[e];</span>
<span class="s2">                                  a_normal_shared[e_m] = a_normal[e];</span>
<span class="s2">                                  b_normal_shared[e_m] = b_normal[e];</span>
<span class="s2">                                  c_normal_shared[e_m] = c_normal[e];</span>
<span class="s2">                                  d_normal_shared[e_m] = d_normal[e];</span>
<span class="s2">                                  a_cf_shared[e_m] = a_cf[e];</span>
<span class="s2">                                  b_cf_shared[e_m] = b_cf[e];</span>
<span class="s2">                                  c_cf_shared[e_m] = c_cf[e];</span>
<span class="s2">                                  d_cf_shared[e_m] = d_cf[e];</span>
<span class="s2">                                  sum_vor_shared[e_m] = sum_vor[e];   </span>

<span class="s2">                                  d2_normal = crystal_pitch_XY * sqrt(a_normal_shared[e_m]*a_normal_shared[e_m]+b_normal_shared[e_m]*b_normal_shared[e_m]+c_normal_shared[e_m]*c_normal_shared[e_m]); </span>
<span class="s2">                                  d2 = crystal_pitch_Z * sqrt(a_shared[e_m]*a_shared[e_m] + b_shared[e_m]*b_shared[e_m] + c_shared[e_m]*c_shared[e_m]);</span>
<span class="s2">                                  d2_cf = distance_between_array_pixel*sqrt(a_cf_shared[e_m]*a_cf_shared[e_m]+b_cf_shared[e_m]*b_cf_shared[e_m]+c_cf_shared[e_m]*c_cf_shared[e_m]);</span>
<span class="s2">                                  max_distance_projector=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf);                             </span>

<span class="s2">                                  for(int l=0; l&lt;n; l++)</span>
<span class="s2">                                  {  </span>
<span class="s2">                                      x_t = l+start_x;</span>
<span class="s2">                                      for(int j=0; j&lt;m; j++)</span>
<span class="s2">                                      {  </span>
<span class="s2">                                         y_t = j+start_y;</span>
<span class="s2">                                         for(int k=0; k&lt;p; k++)</span>
<span class="s2">                                              {</span>
<span class="s2">                                              /*</span>
<span class="s2">                                              index = l+j*n+k*m*n;                                              </span>
<span class="s2">                                              fov_cut_matrix_shared[k]=fov_cut_matrix[k+j*p+l*p*m];</span>
<span class="s2">                                              index = l+j*n+k*m*n; </span>
<span class="s2">                                              */</span>
<span class="s2">                                                index = k+j*p+l*p*m;                                                </span>


<span class="s2">                                              if (fov_cut_matrix[index]!=0)</span>
<span class="s2">                                              {                                                </span>

<span class="s2">                                                  z_t = k+start_z;</span>
<span class="s2">                                                  value_normal = a_normal_shared[e_m]*x_t+b_normal_shared[e_m]*y_t+c_normal_shared[e_m] * z_t -d_normal_shared[e_m];                                                 </span>

<span class="s2">                                                   if (value_normal &lt; d2_normal &amp;&amp; value_normal &gt;= -d2_normal)</span>
<span class="s2">                                                   {</span>
<span class="s2">                                                    value = a_shared[e_m]*x_t+b_shared[e_m]*y_t+c_shared[e_m]*z_t-d_shared[e_m];</span>

<span class="s2">                                                    if (value &lt; d2 &amp;&amp; value &gt;=-d2 )</span>
<span class="s2">                                                     {</span>
<span class="s2">                                                          value_cf = a_cf_shared[e_m]*x_t+b_cf_shared[e_m]*y_t+c_cf_shared[e_m]*z_t-d_cf_shared[e_m];</span>


<span class="s2">                                                      if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
<span class="s2">                                                          {</span>

<span class="s2">                                                           sum_vor_temp +=im_old[index]*(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector);</span>
<span class="s2">                                                           /* im_old[index]*(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector)</span>

<span class="s2">                                                            */</span>
<span class="s2">                                                            }</span>


<span class="s2">                                                  }</span>




<span class="s2">                                              }</span>
<span class="s2">                                              }</span>

<span class="s2">                                           }</span>
<span class="s2">                                       }</span>
<span class="s2">                                   }</span>

<span class="s2">                                   /*</span>
<span class="s2">                                    sum_vor[e]= sum_vor_temp;</span>
<span class="s2">                                   sum_vor[e]= sum_vor_shared[e_m];</span>
<span class="s2">                                   __syncthreads();</span>
<span class="s2">                                   sum_vor[e]= sum_vor_shared[e_m];</span>
<span class="s2">                                   */</span>
<span class="s2">                                   sum_vor[e]= sum_vor_temp;</span>



<span class="s2">               }&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">mod_normalization_shared_mem</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                             #include &lt;stdint.h&gt;</span>
<span class="s2">                             texture&lt;uint8_t, 1&gt; tex;</span>

<span class="s2">                      __global__ void normalization</span>
<span class="s2">                       ( int dataset_number, int n, int m, int p, const float crystal_pitch_XY, const float crystal_pitch_Z, </span>
<span class="s2">                       const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation, </span>
<span class="s2">                       const int end_event_gpu_limitation, const float *a, const float *a_normal, const float *a_cf, const float *b,</span>
<span class="s2">                       const float *b_normal, const float *b_cf, const float *c, const float *c_normal, const float *c_cf, const float *d, const float *d_normal,</span>
<span class="s2">                       const float *d_cf, const short *A, const short *B, const short *C, float *adjust_coef, float *sum_vor, </span>
<span class="s2">                       char *fov_cut_matrix, float *time_factor)</span>
<span class="s2">                       {</span>
<span class="s2">                                 extern __shared__ float adjust_coef_shared[];      </span>
<span class="s2">                                 int idt=blockIdx.x *blockDim.x + threadIdx.x;                            </span>


<span class="s2">                                 float d2;</span>
<span class="s2">                                 float d2_normal;</span>
<span class="s2">                                 float d2_cf;</span>
<span class="s2">                                 float normal_value;</span>
<span class="s2">                                 float value;</span>
<span class="s2">                                 float value_cf;                                              </span>
<span class="s2">                                 short a_temp;</span>
<span class="s2">                                 short b_temp;</span>
<span class="s2">                                 short c_temp;</span>
<span class="s2">                                 char fov_cut_temp;   </span>
<span class="s2">                                 int i_s=threadIdx.x;</span>

<span class="s2">                                 if (idt&gt;n*m*p)</span>
<span class="s2">                                 {</span>
<span class="s2">                                      return;</span>
<span class="s2">                                  }</span>

<span class="s2">                                 __syncthreads();</span>
<span class="s2">                                 adjust_coef_shared[i_s] = adjust_coef[idt];</span>
<span class="s2">                                 a_temp = A[idt];</span>
<span class="s2">                                 b_temp = B[idt];</span>
<span class="s2">                                 c_temp = C[idt];</span>
<span class="s2">                                 fov_cut_temp = fov_cut_matrix[idt];</span>



<span class="s2">                                 for(int e=begin_event_gpu_limitation; e&lt;end_event_gpu_limitation; e++)</span>
<span class="s2">                                 {</span>
<span class="s2">                                     if (fov_cut_temp!=0)</span>
<span class="s2">                                     {   </span>
<span class="s2">                                     normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
<span class="s2">                                     d2_normal = crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>

<span class="s2">                                     if (normal_value&lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
<span class="s2">                                     {</span>
<span class="s2">                                     value = a[e]*a_temp+b[e]*b_temp +c[e]*c_temp- d[e];</span>
<span class="s2">                                     d2 = crystal_pitch_Z * sqrt(a[e]*a[e] + b[e]*b[e] + c[e]*c[e]);</span>


<span class="s2">                                         if (value &lt; d2 &amp;&amp; value &gt;=-d2)</span>
<span class="s2">                                         {</span>
<span class="s2">                                                   value_cf = a_cf[e]*a_temp+b_cf[e]*b_temp +c_cf[e] * c_temp-d_cf[e];</span>
<span class="s2">                                                   d2_cf = distance_between_array_pixel*sqrt(a_cf[e]*a_cf[e]+b_cf[e]*b_cf[e]+c_cf[e]*c_cf[e]);</span>


<span class="s2">                                                     if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
<span class="s2">                                                     {    </span>


<span class="s2">                                                            adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf));</span>


<span class="s2">                                                    }</span>

<span class="s2">                                                         /*</span>

<span class="s2">                                                         adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf));</span>
<span class="s2">                                                         adjust_coef_shared[i_s] += 1/sum_vor[e];  </span>
<span class="s2">                                                         normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
<span class="s2">                                          d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
<span class="s2">                                                        adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);  </span>
<span class="s2">                                                       adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);  </span>
<span class="s2">                                                          */</span>





<span class="s2">                                              }</span>
<span class="s2">                                          }</span>

<span class="s2">                                 }</span>

<span class="s2">                                 }</span>

<span class="s2">                                 adjust_coef[idt] = adjust_coef_shared[i_s];</span>
<span class="s2">                                 __syncthreads();</span>



<span class="s2">                             }</span>
<span class="s2">                             &quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">mod_backward_projection_shared_mem</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                      #include &lt;stdint.h&gt;</span>
<span class="s2">                      texture&lt;uint8_t, 1&gt; tex;</span>

<span class="s2">               __global__ void backprojection</span>
<span class="s2">                ( int dataset_number, int n, int m, int p, const float crystal_pitch_XY, const float crystal_pitch_Z, </span>
<span class="s2">                const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation, </span>
<span class="s2">                const int end_event_gpu_limitation, const float *a, const float *a_normal, const float *a_cf, const float *b,</span>
<span class="s2">                const float *b_normal, const float *b_cf, const float *c, const float *c_normal, const float *c_cf, const float *d, const float *d_normal,</span>
<span class="s2">                const float *d_cf, const short *A, const short *B, const short *C, float *adjust_coef, float *sum_vor, </span>
<span class="s2">                char *fov_cut_matrix, float *time_factor)</span>
<span class="s2">                {</span>
<span class="s2">                          extern __shared__ float adjust_coef_shared[];      </span>
<span class="s2">                          int idt=blockIdx.x *blockDim.x + threadIdx.x;                            </span>


<span class="s2">                          float d2;</span>
<span class="s2">                          float d2_normal;</span>
<span class="s2">                          float d2_cf;</span>
<span class="s2">                          float normal_value;</span>
<span class="s2">                          float value;</span>
<span class="s2">                          float value_cf;                                              </span>
<span class="s2">                          short a_temp;</span>
<span class="s2">                          short b_temp;</span>
<span class="s2">                          short c_temp;</span>
<span class="s2">                          char fov_cut_temp;   </span>
<span class="s2">                          int i_s=threadIdx.x;</span>

<span class="s2">                          if (idt&gt;n*m*p)</span>
<span class="s2">                          {</span>
<span class="s2">                               return;</span>
<span class="s2">                           }</span>

<span class="s2">                          __syncthreads();</span>
<span class="s2">                          adjust_coef_shared[i_s] = adjust_coef[idt];</span>
<span class="s2">                          a_temp = A[idt];</span>
<span class="s2">                          b_temp = B[idt];</span>
<span class="s2">                          c_temp = C[idt];</span>
<span class="s2">                          fov_cut_temp = fov_cut_matrix[idt];</span>



<span class="s2">                          for(int e=begin_event_gpu_limitation; e&lt;end_event_gpu_limitation; e++)</span>
<span class="s2">                          {</span>
<span class="s2">                              if (fov_cut_temp!=0)</span>
<span class="s2">                              {   </span>
<span class="s2">                              normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
<span class="s2">                              d2_normal = crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>

<span class="s2">                              if (normal_value&lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
<span class="s2">                              {</span>
<span class="s2">                              value = a[e]*a_temp+b[e]*b_temp +c[e]*c_temp- d[e];</span>
<span class="s2">                              d2 = crystal_pitch_Z * sqrt(a[e]*a[e] + b[e]*b[e] + c[e]*c[e]);</span>


<span class="s2">                                  if (value &lt; d2 &amp;&amp; value &gt;=-d2)</span>
<span class="s2">                                  {</span>
<span class="s2">                                            value_cf = a_cf[e]*a_temp+b_cf[e]*b_temp +c_cf[e] * c_temp-d_cf[e];</span>
<span class="s2">                                            d2_cf = distance_between_array_pixel*sqrt(a_cf[e]*a_cf[e]+b_cf[e]*b_cf[e]+c_cf[e]*c_cf[e]);</span>


<span class="s2">                                              if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
<span class="s2">                                              {    </span>



<span class="s2">                                                    adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]*time_factor[e]);</span>

<span class="s2">                                             }</span>

<span class="s2">                                                  /*</span>

<span class="s2">                                                  adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]*time_factor[e]);</span>
<span class="s2">                                                  adjust_coef_shared[i_s] += 1/sum_vor[e];  </span>
<span class="s2">                                                  normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
<span class="s2">                                   d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
<span class="s2">                                                 adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);  </span>
<span class="s2">                                                adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);  </span>
<span class="s2">                                                   */</span>





<span class="s2">                                       }</span>
<span class="s2">                                   }</span>

<span class="s2">                          }</span>

<span class="s2">                          }</span>

<span class="s2">                          adjust_coef[idt] = adjust_coef_shared[i_s];</span>
<span class="s2">                          __syncthreads();</span>



<span class="s2">                      }</span>
<span class="s2">                      &quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">mod_forward_projection_shared_mem_cdrf</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">               #include &lt;stdint.h&gt;</span>

<span class="s2">               texture&lt;char, 1&gt; tex;</span>


<span class="s2">               __global__ void forward_projection_cdrf</span>
<span class="s2">               (const int n, const int m, const int p, const int start_x, const int start_y, const int start_z,</span>
<span class="s2">               float *crystal_pitch_XY, float *crystal_pitch_Z,const float distance_between_array_pixel,</span>
<span class="s2">               int number_of_events, const int begin_event_gpu_limitation,  const int end_event_gpu_limitation, </span>
<span class="s2">               float *a, float *a_normal, float *a_cf, float *b,float *b_normal, float *b_cf,float *c,float *c_normal, </span>
<span class="s2">               float *c_cf, float *d, float *d_normal, float *d_cf, float *sum_vor, const char *fov_cut_matrix, </span>
<span class="s2">               const float *im_old, float* m_values, float* b_values, float* m_values_at, float* b_values_at,</span>
<span class="s2">                                     float* max_D, float* inflex_points_x, float* linear_attenuation_A,</span>
<span class="s2">                                     float* linear_attenuation_B)</span>
<span class="s2">                                      {</span>
<span class="s2">                                         const int shared_memory_size = 256;</span>
<span class="s2">                                          __shared__ float a_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float b_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float c_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float d_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float a_normal_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float b_normal_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float c_normal_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float d_normal_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float a_cf_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float b_cf_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float c_cf_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float d_cf_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float sum_vor_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ char fov_cut_matrix_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float crystal_pitch_Z_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float crystal_pitch_XY_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float m_values_init_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float m_values_end_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float b_values_init_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float b_values_end_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float m_values_at_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float b_values_at_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float max_D_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float inflex_points_x_init_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float inflex_points_x_end_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float linear_attenuation_A_shared[shared_memory_size];</span>
<span class="s2">                                          __shared__ float linear_attenuation_B_shared[shared_memory_size];</span>
<span class="s2">                                          </span>
<span class="s2">                                          /*</span>
<span class="s2">                                         const int blockId = blockIdx.x+ blockIdx.y * gridDim.x+ gridDim.x * gridDim.y * blockIdx.z;</span>
<span class="s2">                                         const int threadId= blockId * (blockDim.x * blockDim.y * blockDim.z)+ (threadIdx.z * (blockDim.x * blockDim.y))+ (threadIdx.y * blockDim.x)+ threadIdx.x;</span>
<span class="s2">                                         */</span>
<span class="s2">                                         int threadId=blockIdx.x *blockDim.x + threadIdx.x;</span>
<span class="s2">                                         int e;</span>

<span class="s2">                                         float d2;</span>
<span class="s2">                                         float d2_normal;</span>
<span class="s2">                                         float d2_cf;</span>
<span class="s2">                                         float value;</span>
<span class="s2">                                         float value_normal;</span>
<span class="s2">                                         float value_cf;</span>
<span class="s2">                                         float sum_vor_temp;</span>
<span class="s2">                                         int index;                                  </span>
<span class="s2">                                         int x_t;</span>
<span class="s2">                                         int y_t;</span>
<span class="s2">                                         int z_t;</span>
<span class="s2">                                         float width;</span>
<span class="s2">                                         float height;</span>
<span class="s2">                                         float distance;</span>
<span class="s2">                                         float distance_other; </span>
<span class="s2">                                         float distance_crystal;</span>
<span class="s2">                                         float distance_at;</span>
<span class="s2">                                         float idrf;</span>
<span class="s2">                                         </span>


<span class="s2">                                         float max_distance_projector;</span>

<span class="s2">                                         const int number_events_max = end_event_gpu_limitation-begin_event_gpu_limitation;</span>
<span class="s2">                                         const float error_pixel = 0.0000f;</span>
<span class="s2">                                          if (threadIdx.x&gt;shared_memory_size)</span>
<span class="s2">                                          {</span>
<span class="s2">                                          return;</span>
<span class="s2">                                          }</span>
<span class="s2">                                          if(threadId&gt;number_events_max)</span>
<span class="s2">                                          {</span>
<span class="s2">                                          return;</span>
<span class="s2">                                          }</span>

<span class="s2">                                         __syncthreads();</span>
<span class="s2">                                         e = threadId;</span>
<span class="s2">                                         int e_m = threadIdx.x;</span>
<span class="s2">                                         a_shared[e_m] = a[e];</span>
<span class="s2">                                         b_shared[e_m] = b[e];</span>
<span class="s2">                                         c_shared[e_m] = c[e];</span>
<span class="s2">                                         d_shared[e_m] = d[e];</span>
<span class="s2">                                         a_normal_shared[e_m] = a_normal[e];</span>
<span class="s2">                                         b_normal_shared[e_m] = b_normal[e];</span>
<span class="s2">                                         c_normal_shared[e_m] = c_normal[e];</span>
<span class="s2">                                         d_normal_shared[e_m] = d_normal[e];</span>
<span class="s2">                                         a_cf_shared[e_m] = a_cf[e];</span>
<span class="s2">                                         b_cf_shared[e_m] = b_cf[e];</span>
<span class="s2">                                         c_cf_shared[e_m] = c_cf[e];</span>
<span class="s2">                                         d_cf_shared[e_m] = d_cf[e];</span>
<span class="s2">                                         sum_vor_shared[e_m] = sum_vor[e];</span>
<span class="s2">                                         crystal_pitch_Z_shared[e_m] =  crystal_pitch_Z[e];  </span>
<span class="s2">                                         crystal_pitch_XY_shared[e_m] =  crystal_pitch_XY[e];  </span>
<span class="s2">                                         m_values_init_shared[e_m] =  m_values[2*e];  </span>
<span class="s2">                                         m_values_end_shared[e_m] =  m_values[2*e+1];  </span>
<span class="s2">                                         b_values_init_shared[e_m] =  b_values[2*e];  </span>
<span class="s2">                                         b_values_end_shared[e_m] =  b_values[2*e+1];  </span>
<span class="s2">                                         m_values_at_shared[e_m] =  m_values_at[e];  </span>
<span class="s2">                                         b_values_at_shared[e_m] =  b_values_at[e];  </span>
<span class="s2">                                         max_D_shared[e_m] = max_D[e];  </span>
<span class="s2">                                         inflex_points_x_init_shared[e_m] =  inflex_points_x[2*e];  </span>
<span class="s2">                                         inflex_points_x_end_shared[e_m] =  inflex_points_x[2*e+1];  </span>
<span class="s2">                                         linear_attenuation_A_shared[e_m] =  linear_attenuation_A[e];  </span>
<span class="s2">                                         linear_attenuation_B_shared[e_m] =  linear_attenuation_B[e];  </span>

<span class="s2">                                         d2_normal = crystal_pitch_XY_shared[e_m] * sqrt(a_normal_shared[e_m]*a_normal_shared[e_m]+b_normal_shared[e_m]*b_normal_shared[e_m]+c_normal_shared[e_m]*c_normal_shared[e_m]); </span>
<span class="s2">                                         d2 = crystal_pitch_Z_shared[e_m]* sqrt(a_shared[e_m]*a_shared[e_m] + b_shared[e_m]*b_shared[e_m] + c_shared[e_m]*c_shared[e_m]);</span>
<span class="s2">                                         d2_cf = distance_between_array_pixel*sqrt(a_cf_shared[e_m]*a_cf_shared[e_m]+b_cf_shared[e_m]*b_cf_shared[e_m]+c_cf_shared[e_m]*c_cf_shared[e_m]);</span>
<span class="s2">                                         max_distance_projector=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf);                             </span>

<span class="s2">                                         for(int l=0; l&lt;n; l++)</span>
<span class="s2">                                         {  </span>
<span class="s2">                                             x_t = l+start_x;</span>
<span class="s2">                                             for(int j=0; j&lt;m; j++)</span>
<span class="s2">                                             {  </span>
<span class="s2">                                                y_t = j+start_y;</span>
<span class="s2">                                                for(int k=0; k&lt;p; k++)</span>
<span class="s2">                                                     {</span>
<span class="s2">                                                     /*</span>
<span class="s2">                                                     index = l+j*n+k*m*n;                                              </span>
<span class="s2">                                                     fov_cut_matrix_shared[k]=fov_cut_matrix[k+j*p+l*p*m];</span>
<span class="s2">                                                     index = l+j*n+k*m*n; </span>
<span class="s2">                                                     */</span>
<span class="s2">                                                       index = k+j*p+l*p*m;                                                </span>


<span class="s2">                                                     if (fov_cut_matrix[index]!=0)</span>
<span class="s2">                                                     {                                                </span>

<span class="s2">                                                         z_t = k+start_z;</span>
<span class="s2">                                                         value_normal = a_normal_shared[e_m]*x_t+b_normal_shared[e_m]*y_t+c_normal_shared[e_m] * z_t -d_normal_shared[e_m];                                                 </span>

<span class="s2">                                                          if (value_normal &lt; d2_normal &amp;&amp; value_normal &gt;= -d2_normal)</span>
<span class="s2">                                                          {</span>
<span class="s2">                                                           value = a_shared[e_m]*x_t+b_shared[e_m]*y_t+c_shared[e_m]*z_t-d_shared[e_m];</span>

<span class="s2">                                                           if (value &lt; d2 &amp;&amp; value &gt;=-d2 )</span>
<span class="s2">                                                            {</span>
<span class="s2">                                                                 value_cf = a_cf_shared[e_m]*x_t+b_cf_shared[e_m]*y_t+c_cf_shared[e_m]*z_t-d_cf_shared[e_m];</span>


<span class="s2">                                                             if (value_cf &gt;= -d2_cf &amp;&amp; value_cf&lt;d2_cf)</span>
<span class="s2">                                                                 {</span>
<span class="s2">                                                                 if (sqrt(value*value+value_normal*value_normal+value_cf*value_cf)&lt;=max_distance_projector)</span>
<span class="s2">                                                                 {      </span>
<span class="s2">                                                                     width = 2*(crystal_pitch_Z_shared[e_m]  - abs(value));</span>
<span class="s2">                                                                    height = 2*(crystal_pitch_XY_shared[e_m] - abs(value_normal));</span>

<span class="s2">                                                                     distance =d2_cf+abs(value_cf);</span>
<span class="s2">                                                                    distance_other = abs(d2_cf+value_cf);</span>
<span class="s2">                                                                        </span>
<span class="s2">                                                                    distance_at = m_values_at_shared[e_m]*value+b_values_at_shared[e_m];</span>
<span class="s2">                                                                 </span>
<span class="s2">                                                                      </span>
<span class="s2">                                                                if(value&lt;=inflex_points_x_init_shared[e_m])</span>
<span class="s2">                                                                {</span>
<span class="s2">                                                                    distance_crystal = m_values_init_shared[e_m]*value+b_values_init_shared[e_m];</span>
<span class="s2">                                                                    distance_at = 0;</span>
<span class="s2">                                                                }</span>
<span class="s2">                                                                 </span>
<span class="s2">                                                             </span>
<span class="s2">                                                                else if(value&gt;=inflex_points_x_end_shared[e_m])</span>
<span class="s2">                                                                {</span>
<span class="s2">                                                                    distance_crystal = m_values_end_shared[e_m]*value+b_values_end_shared[e_m];</span>
<span class="s2">                                                                }</span>
<span class="s2">                                                                </span>
<span class="s2">                                                                else </span>
<span class="s2">                                                                {</span>
<span class="s2">                                                                    distance_crystal = max_D_shared[e_m];</span>
<span class="s2">                                                                    </span>
<span class="s2">                                                                    </span>
<span class="s2">                                                                }</span>
<span class="s2">                                                                </span>
<span class="s2">                                                              </span>
<span class="s2">                                                              </span>
<span class="s2">                                                               idrf=(1-exp(-linear_attenuation_A_shared[e_m]*distance_crystal))*exp(-linear_attenuation_A_shared[e_m]*distance_at);</span>
<span class="s2">                                                               if (idrf&lt;0)</span>
<span class="s2">                                                               {</span>
<span class="s2">                                                              </span>
<span class="s2">                                                               idrf = 0;</span>
<span class="s2">                                                               }</span>
<span class="s2">                                                                </span>
<span class="s2">                                                              </span>
<span class="s2">                                                              </span>
<span class="s2">                                                                </span>
<span class="s2">                                                                  sum_vor_shared[e_m]+= idrf*im_old[index];</span>
<span class="s2">                                                                  </span>
<span class="s2">                                                                  </span>

<span class="s2">                                                                  }</span>
<span class="s2">                                                                  /*</span>
<span class="s2">                                                                  pow(4*atan(width*height/(2*distance*sqrt(4*distance*distance+width*width+height*height))),2)</span>
<span class="s2">                                                                  sum_vor_shared[e_m]+= im_old[index]*(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector);</span>
<span class="s2">                                                                  4*arctan(</span>
<span class="s2">                                                                  4*np.arctan(width*height/(2*distance_to_anh*np.sqrt(4*distance_between_array_pixel-value_cf)**2+width**2+height**2)))</span>
<span class="s2">                                                                  *(1-sqrt(value*value+value_normal*value_normal+value_cf*value_cf)/max_distance_projector)</span>
<span class="s2">                                                                  */</span>
<span class="s2">                                                                   }</span>


<span class="s2">                                                         }</span>




<span class="s2">                                                     }</span>
<span class="s2">                                                     }</span>

<span class="s2">                                                  }</span>
<span class="s2">                                              }</span>
<span class="s2">                                          }</span>

<span class="s2">                                          /*</span>
<span class="s2">                                           sum_vor[e]= sum_vor_temp;</span>
<span class="s2">                                          sum_vor[e]= sum_vor_shared[e_m];</span>


<span class="s2">                                          sum_vor[e]= sum_vor_temp;</span>
<span class="s2">                                          */</span>
<span class="s2">                                          __syncthreads();</span>
<span class="s2">                                          sum_vor[e]= sum_vor_shared[e_m];</span>



<span class="s2">                      }&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="n">mod_normalization_shared_mem_cdrf</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        #include &lt;stdint.h&gt;</span>
<span class="s2">        </span>
<span class="s2">        texture&lt;uint8_t, 1&gt; tex;</span>
<span class="s2">        __device__ float* three_plane_intersection(float plane1A, float plane1B,</span>
<span class="s2">            float plane1C, float plane1D, float plane2A, float plane2B, float plane2C,</span>
<span class="s2">            float plane2D, float plane3A, float plane3B, float plane3C, float plane3D);</span>
<span class="s2">        __device__ float intersection_determinant(float matrix[3][3]);</span>
<span class="s2">        __device__ float point_distance_to_plane(float *point, float A, float B, float C, float D);</span>
<span class="s2">        </span>
<span class="s2">        __global__ void normalization_cdrf</span>
<span class="s2">        (int dataset_number, int n, int m, int p, float* crystal_pitch_XY, float* crystal_pitch_Z,</span>
<span class="s2">            const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation,</span>
<span class="s2">            const int end_event_gpu_limitation, const float* a, const float* a_normal, const float* a_cf, const float* b,</span>
<span class="s2">            const float* b_normal, const float* b_cf, const float* c, const float* c_normal, const float* c_cf, const float* d, const float* d_normal,</span>
<span class="s2">            const float* d_cf, const short* A, const short* B, const short* C, float* adjust_coef, float* sum_vor,</span>
<span class="s2">            char* fov_cut_matrix, float* time_factor, float* plane_centerA1_A,</span>
<span class="s2">            float* plane_centerA1_B, float* plane_centerA1_C, float* plane_centerA1_D,</span>
<span class="s2">            float* plane_centerB1_A, float* plane_centerB1_B, float* plane_centerB1_C,</span>
<span class="s2">            float* plane_centerB1_D, float* plane_centerC1_A, float* plane_centerC1_B,</span>
<span class="s2">            float* plane_centerC1_C, float* plane_centerC1_D, float* intersection_points, float* m_values, float* m_values_at,</span>
<span class="s2">            float* b_values, float* b_values_at, float* max_D, float* inflex_points_x, float* linear_attenuation_A,</span>
<span class="s2">            float* linear_attenuation_B)</span>
<span class="s2">        {</span>
<span class="s2">            extern __shared__ float adjust_coef_shared[];</span>
<span class="s2">            int idt = blockIdx.x * blockDim.x + threadIdx.x;</span>
<span class="s2">        </span>
<span class="s2">        </span>
<span class="s2">            float d2;</span>
<span class="s2">            float d2_normal;</span>
<span class="s2">            float d2_cf;</span>
<span class="s2">            float normal_value;</span>
<span class="s2">            float value;</span>
<span class="s2">            float value_cf;</span>
<span class="s2">            short a_temp;</span>
<span class="s2">            short b_temp;</span>
<span class="s2">            short c_temp;</span>
<span class="s2">            char fov_cut_temp;</span>
<span class="s2">            int i_s = threadIdx.x;</span>
<span class="s2">            float width;</span>
<span class="s2">            float height;</span>
<span class="s2">            float distance;           </span>
<span class="s2">            float solid_angle;</span>
<span class="s2">            float face_1_distance_to_center;</span>
<span class="s2">            float face_2_distance_to_center;</span>
<span class="s2">            float face_3_distance_to_center;</span>
<span class="s2">            float* p1;          </span>
<span class="s2">            float* p2;          </span>
<span class="s2">            float* p3;          </span>
<span class="s2">            float* p4;          </span>
<span class="s2">            float* p5;          </span>
<span class="s2">            float* p6;            </span>
<span class="s2">            float dist_p1;</span>
<span class="s2">            float distance_crystal;    </span>
<span class="s2">            float distance_at;</span>
<span class="s2">            float idrf;      </span>
<span class="s2">           </span>
<span class="s2">            if (idt &gt;= n * m * p)</span>
<span class="s2">            {</span>
<span class="s2">                return;</span>
<span class="s2">            }</span>
<span class="s2">        </span>
<span class="s2">            __syncthreads();</span>
<span class="s2">            adjust_coef_shared[i_s] = adjust_coef[idt];</span>
<span class="s2">            a_temp = A[idt];</span>
<span class="s2">            b_temp = B[idt];</span>
<span class="s2">            c_temp = C[idt];</span>
<span class="s2">            fov_cut_temp = fov_cut_matrix[idt];</span>
<span class="s2">        </span>
<span class="s2">            for (int e = begin_event_gpu_limitation; e &lt; end_event_gpu_limitation; e++)</span>
<span class="s2">            {</span>
<span class="s2">                if (fov_cut_temp != 0)</span>
<span class="s2">                {</span>
<span class="s2">                    normal_value = a_normal[e] * a_temp + b_normal[e] * b_temp + c_normal[e] * c_temp - d_normal[e];</span>
<span class="s2">                    d2_normal = crystal_pitch_XY[e] * sqrt(a_normal[e] * a_normal[e] + b_normal[e] * b_normal[e] + c_normal[e] * c_normal[e]);</span>
<span class="s2">        </span>
<span class="s2">                    if (normal_value &lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
<span class="s2">                    {</span>
<span class="s2">                        value = a[e] * a_temp + b[e] * b_temp + c[e] * c_temp - d[e];</span>
<span class="s2">                        d2 = crystal_pitch_Z[e] * sqrt(a[e] * a[e] + b[e] * b[e] + c[e] * c[e]);</span>
<span class="s2">        </span>
<span class="s2">        </span>
<span class="s2">                        if (value &lt; d2 &amp;&amp; value &gt;= -d2)</span>
<span class="s2">                        {</span>
<span class="s2">                            value_cf = a_cf[e] * a_temp + b_cf[e] * b_temp + c_cf[e] * c_temp - d_cf[e];</span>
<span class="s2">                            d2_cf = distance_between_array_pixel * sqrt(a_cf[e] * a_cf[e] + b_cf[e] * b_cf[e] + c_cf[e] * c_cf[e]);</span>
<span class="s2">        </span>
<span class="s2">        </span>
<span class="s2">                            if (value_cf &gt;= -d2_cf &amp;&amp; value_cf &lt; d2_cf)</span>
<span class="s2">                            {</span>
<span class="s2">        </span>
<span class="s2">                                width = 2 * (crystal_pitch_Z[e] - abs(value));</span>
<span class="s2">                                height = 2 * (crystal_pitch_XY[e] - abs(normal_value));</span>
<span class="s2">                                distance = d2_cf + abs(value_cf);</span>
<span class="s2">                                                              </span>
<span class="s2">                               /*</span>
<span class="s2">                                face_1_distance_to_center = 1.0f * sqrt(plane_centerA1_A[e] * plane_centerA1_A[e] + plane_centerA1_B[e] * plane_centerA1_B[e] + plane_centerA1_C[e] * plane_centerA1_C[e]);</span>
<span class="s2">                                face_2_distance_to_center = 1.0f * sqrt(plane_centerB1_A[e] * plane_centerB1_A[e] + plane_centerB1_B[e] * plane_centerB1_B[e] + plane_centerB1_C[e] * plane_centerB1_C[e]);</span>
<span class="s2">                                face_3_distance_to_center = 15.0f * sqrt(plane_centerC1_A[e] * plane_centerC1_A[e] + plane_centerC1_B[e] * plane_centerC1_B[e] + plane_centerC1_C[e] * plane_centerC1_C[e]);</span>
<span class="s2">                                </span>
<span class="s2">                                p1 = three_plane_intersection(a[e],</span>
<span class="s2">                                    b[e], c[e], d[e],</span>
<span class="s2">                                    a_normal[e], b_normal[e], c_normal[e],</span>
<span class="s2">                                    d_normal[e], plane_centerA1_A[e], plane_centerA1_B[e],</span>
<span class="s2">                                    plane_centerA1_C[e], plane_centerA1_D[e]+face_1_distance_to_center);</span>
<span class="s2">                                    </span>
<span class="s2">                                p2 = three_plane_intersection(a[e],</span>
<span class="s2">                                    b[e], c[e], d[e],</span>
<span class="s2">                                    a_normal[e], b_normal[e], c_normal[e],</span>
<span class="s2">                                    d_normal[e], plane_centerA1_A[e], plane_centerA1_B[e],</span>
<span class="s2">                                    plane_centerA1_C[e], plane_centerA1_D[e]-face_1_distance_to_center);                                    </span>
<span class="s2">                                               </span>
<span class="s2">                                p3 = three_plane_intersection(a[e],</span>
<span class="s2">                                    b[e], c[e], d[e],</span>
<span class="s2">                                    a_normal[e], b_normal[e], c_normal[e],</span>
<span class="s2">                                    d_normal[e], plane_centerB1_A[e], plane_centerB1_B[e],</span>
<span class="s2">                                    plane_centerB1_C[e], plane_centerB1_D[e]+face_2_distance_to_center);</span>
<span class="s2">                                    </span>
<span class="s2">                                p4 = three_plane_intersection(a[e],</span>
<span class="s2">                                    b[e], c[e], d[e],</span>
<span class="s2">                                    a_normal[e], b_normal[e], c_normal[e],</span>
<span class="s2">                                    d_normal[e], plane_centerB1_A[e], plane_centerB1_B[e],</span>
<span class="s2">                                    plane_centerB1_C[e], plane_centerB1_D[e]-face_2_distance_to_center);</span>
<span class="s2">                                    </span>
<span class="s2">                                p5 = three_plane_intersection(a[e],</span>
<span class="s2">                                    b[e], c[e], d[e],</span>
<span class="s2">                                    a_normal[e], b_normal[e], c_normal[e],</span>
<span class="s2">                                    d_normal[e], plane_centerC1_A[e], plane_centerC1_B[e],</span>
<span class="s2">                                    plane_centerC1_C[e], plane_centerC1_D[e]+face_3_distance_to_center);</span>
<span class="s2">                                    </span>
<span class="s2">                                p6 = three_plane_intersection(a[e],</span>
<span class="s2">                                    b[e], c[e], d[e],</span>
<span class="s2">                                    a_normal[e], b_normal[e], c_normal[e],</span>
<span class="s2">                                    d_normal[e], plane_centerC1_A[e], plane_centerC1_B[e],</span>
<span class="s2">                                    plane_centerC1_C[e], plane_centerC1_D[e]-face_3_distance_to_center);            </span>
<span class="s2">                                    </span>
<span class="s2">                                intersection_points[e*6] = point_distance_to_plane(p1, a_cf[e], b_cf[e],c_cf[e], d_cf[e]); </span>
<span class="s2">                                dist_p2 = point_distance_to_plane(p2, a_cf[e], b_cf[e],c_cf[e], d_cf[e]);</span>
<span class="s2">                                </span>
<span class="s2">                              </span>
<span class="s2">                                                     </span>
<span class="s2">                                 printf(&quot; Distance p1: </span><span class="si">%f</span><span class="s2">&quot;, intersection_points[e*6]);</span>
<span class="s2">                               </span>
<span class="s2">                                  dist_p2 = point_distance_to_plane(p2, a_cf[e], b_cf[e],c_cf[e], d_cf[e]);                     </span>
<span class="s2">                                dist_p3 = point_distance_to_plane(p3, a_cf[e], b_cf[e],c_cf[e], d_cf[e]);                     </span>
<span class="s2">                                dist_p4 = point_distance_to_plane(p4, a_cf[e], b_cf[e],c_cf[e], d_cf[e]);                     </span>
<span class="s2">                                dist_p5 = point_distance_to_plane(p5, a_cf[e], b_cf[e],c_cf[e], d_cf[e]);                     </span>
<span class="s2">                                dist_p6 = point_distance_to_plane(p6, a_cf[e], b_cf[e],c_cf[e], d_cf[e]);</span>
<span class="s2">                                printf(&quot; Distance p1: </span><span class="si">%f</span><span class="s2">&quot;, dist_p1);</span>
<span class="s2">                                printf(&quot; x: </span><span class="si">%f</span><span class="s2">, y: </span><span class="si">%f</span><span class="s2">, z: </span><span class="si">%f</span><span class="s2"> &quot;,p1[0], p1[1], p1[2]);</span>
<span class="s2">                                printf(&quot;----------------&quot;);</span>
<span class="s2">                                printf(&quot; x_2: </span><span class="si">%f</span><span class="s2">, y_2: </span><span class="si">%f</span><span class="s2">, z_2: </span><span class="si">%f</span><span class="s2"> &quot;,p2[0], p2[1], p2[2]);</span>
<span class="s2">                              */</span>
<span class="s2">                                distance_at = m_values_at[e]*value+b_values_at[e];</span>
<span class="s2">                                                                   </span>
<span class="s2">                                if(value&lt;=inflex_points_x[2*e])</span>
<span class="s2">                                {</span>
<span class="s2">                                    distance_crystal = m_values[2*e]*value+b_values[2*e];</span>
<span class="s2">                                    distance_at = 0;</span>
<span class="s2">                                }</span>
<span class="s2">                                 else if(value&gt;=inflex_points_x[2*e+1])</span>
<span class="s2">                                {</span>
<span class="s2">                                    distance_crystal = m_values[2*e+1]*value+b_values[2*e+1];</span>
<span class="s2">                                }</span>
<span class="s2">                               </span>
<span class="s2">                                else </span>
<span class="s2">                                {</span>
<span class="s2">                                    distance_crystal = max_D[e];</span>
<span class="s2">                                    </span>
<span class="s2">                                    </span>
<span class="s2">                                }</span>
<span class="s2">                                distance_crystal = max_D[e];</span>
<span class="s2">                                idrf = (1-exp(-linear_attenuation_A[e]*distance_crystal))*exp(-linear_attenuation_A[e]*distance_at);</span>
<span class="s2">                             </span>
<span class="s2">                                </span>
<span class="s2">                                </span>
<span class="s2">                                solid_angle = 4 * width * height / (2 * distance * sqrt(4 * distance * distance + width * width + height * height));</span>
<span class="s2">        </span>
<span class="s2">        </span>
<span class="s2">                                adjust_coef_shared[i_s] +=  idrf/(sum_vor[e]);</span>
<span class="s2">                                 </span>
<span class="s2">                                /*</span>
<span class="s2">                             else if(value&lt;=inflex_points_x[2*e+1])</span>
<span class="s2">                                {</span>
<span class="s2">                                    distance_crystal = m_values[2*e+1]*value+b_values[2*e+1];</span>
<span class="s2">                                }</span>
<span class="s2">                                </span>
<span class="s2">                                   printf(&quot; x_2: </span><span class="si">%f</span><span class="s2">,  distance: </span><span class="si">%f</span><span class="s2">, att: </span><span class="si">%f</span><span class="s2"> &quot;,idrf,distance_crystal, linear_attenuation_A[e] );</span>
<span class="s2">                                 if (sqrt(value*value+normal_value*normal_value+value_cf*value_cf)&lt;=sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))</span>
<span class="s2">                                {</span>
<span class="s2">                                   adjust_coef_shared[i_s] += time_factor[e]*(1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]);</span>
<span class="s2">                                    }</span>
<span class="s2">                                  */</span>
<span class="s2">        </span>
<span class="s2">        </span>
<span class="s2">                            }</span>
<span class="s2">        </span>
<span class="s2">                            /*</span>
<span class="s2">                            (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/</span>
<span class="s2">                            normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
<span class="s2">             d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
<span class="s2">                           adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);</span>
<span class="s2">                          adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);</span>
<span class="s2">                             */</span>
<span class="s2">        </span>
<span class="s2">                        }</span>
<span class="s2">                    }</span>
<span class="s2">        </span>
<span class="s2">                }</span>
<span class="s2">        </span>
<span class="s2">            }</span>
<span class="s2">        </span>
<span class="s2">            adjust_coef[idt] = adjust_coef_shared[i_s];</span>
<span class="s2">            __syncthreads();</span>
<span class="s2">        </span>
<span class="s2">        }</span>
<span class="s2">        __device__ float point_distance_to_plane(float* point, float A, float B, float C, float D)</span>
<span class="s2">        {</span>
<span class="s2">             float distance;</span>
<span class="s2">             distance = abs(A*point[0]+B*point[1]+C*point[2]-D)/sqrt(A*A+B*B+C*C);</span>
<span class="s2">             return distance;</span>
<span class="s2">        }</span>
<span class="s2">        </span>
<span class="s2">        __device__  float* three_plane_intersection(float plane1A, float plane1B,</span>
<span class="s2">            float plane1C, float plane1D, float plane2A, float plane2B, float plane2C,</span>
<span class="s2">            float plane2D, float plane3A, float plane3B, float plane3C, float plane3D)</span>
<span class="s2">        {</span>
<span class="s2">            float m_det[3][3];</span>
<span class="s2">            float m_x[3][3];</span>
<span class="s2">            float m_y[3][3];</span>
<span class="s2">            float m_z[3][3];</span>
<span class="s2">            float det;</span>
<span class="s2">            float det_x;</span>
<span class="s2">            float det_y;</span>
<span class="s2">            float det_z;</span>
<span class="s2">            float result[3];</span>
<span class="s2">        </span>
<span class="s2">            m_det[0][0] = plane1A;</span>
<span class="s2">            m_det[0][1] = plane1B;</span>
<span class="s2">            m_det[0][2] = plane1C;</span>
<span class="s2">            m_det[1][0] = plane2A;</span>
<span class="s2">            m_det[1][1] = plane2B;</span>
<span class="s2">            m_det[1][2] = plane2C;</span>
<span class="s2">            m_det[2][0] = plane3A;</span>
<span class="s2">            m_det[2][1] = plane3B;</span>
<span class="s2">            m_det[2][2] = plane3C;</span>
<span class="s2">        </span>
<span class="s2">            m_x[0][0] = plane1D;</span>
<span class="s2">            m_x[0][1] = plane1B;</span>
<span class="s2">            m_x[0][2] = plane1C;</span>
<span class="s2">            m_x[1][0] = plane2D;</span>
<span class="s2">            m_x[1][1] = plane2B;</span>
<span class="s2">            m_x[1][2] = plane2C;</span>
<span class="s2">            m_x[2][0] = plane3D;</span>
<span class="s2">            m_x[2][1] = plane3B;</span>
<span class="s2">            m_x[2][2] = plane3C;</span>
<span class="s2">        </span>
<span class="s2">            m_y[0][0] = plane1A;</span>
<span class="s2">            m_y[0][1] = plane1D;</span>
<span class="s2">            m_y[0][2] = plane1C;</span>
<span class="s2">            m_y[1][0] = plane2A;</span>
<span class="s2">            m_y[1][1] = plane2D;</span>
<span class="s2">            m_y[1][2] = plane2C;</span>
<span class="s2">            m_y[2][0] = plane3A;</span>
<span class="s2">            m_y[2][1] = plane3D;</span>
<span class="s2">            m_y[2][2] = plane3C;</span>
<span class="s2">        </span>
<span class="s2">            m_z[0][0] = plane1A;</span>
<span class="s2">            m_z[0][1] = plane1B;</span>
<span class="s2">            m_z[0][2] = plane1D;</span>
<span class="s2">            m_z[1][0] = plane2A;</span>
<span class="s2">            m_z[1][1] = plane2B;</span>
<span class="s2">            m_z[1][2] = plane2D;</span>
<span class="s2">            m_z[2][0] = plane3A;</span>
<span class="s2">            m_z[2][1] = plane3B;</span>
<span class="s2">            m_z[2][2] = plane3D;</span>
<span class="s2">        </span>
<span class="s2">            det = intersection_determinant(m_det);            </span>
<span class="s2">            det_x = intersection_determinant(m_x);</span>
<span class="s2">            det_y = intersection_determinant(m_y);</span>
<span class="s2">            det_z = intersection_determinant(m_z);</span>
<span class="s2">           </span>
<span class="s2">           </span>
<span class="s2">            if (det != 0.0f)</span>
<span class="s2">            {</span>
<span class="s2">                result[0] = det_x / det;</span>
<span class="s2">                result[1] = det_y / det;</span>
<span class="s2">                result[2] = det_z / det;</span>
<span class="s2">            }</span>
<span class="s2">           </span>
<span class="s2">            return result;</span>
<span class="s2">        }</span>
<span class="s2">        </span>
<span class="s2">        __device__ float intersection_determinant(float matrix[3][3])</span>
<span class="s2">        {</span>
<span class="s2">            float a;</span>
<span class="s2">            float b;</span>
<span class="s2">            float c;</span>
<span class="s2">            float d;</span>
<span class="s2">            float e;</span>
<span class="s2">            float f;</span>
<span class="s2">            float g;</span>
<span class="s2">            float h;</span>
<span class="s2">            float i;</span>
<span class="s2">            float det;</span>
<span class="s2">        </span>
<span class="s2">            a = matrix[0][0];</span>
<span class="s2">            b = matrix[0][1];</span>
<span class="s2">            c = matrix[0][2];</span>
<span class="s2">            d = matrix[1][0];</span>
<span class="s2">            e = matrix[1][1];</span>
<span class="s2">            f = matrix[1][2];</span>
<span class="s2">            g = matrix[2][0];</span>
<span class="s2">            h = matrix[2][1];</span>
<span class="s2">            i = matrix[2][2];</span>
<span class="s2">        </span>
<span class="s2">            det = (a * e * i + b * f * g + c * d * h) - (a * f * h + b * d * i + c * e * g);</span>
<span class="s2">            return det;</span>
<span class="s2">        }</span>
<span class="s2">                                     &quot;&quot;&quot;</span><span class="p">)</span>

        <span class="n">mod_backward_projection_shared_mem_cdrf</span> <span class="o">=</span> <span class="n">SourceModule</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            #include &lt;stdint.h&gt;</span>
<span class="s2">            texture&lt;uint8_t, 1&gt; tex;</span>
<span class="s2">            </span>
<span class="s2">            __global__ void backprojection_cdrf</span>
<span class="s2">            (int dataset_number, int n, int m, int p, const float* crystal_pitch_XY, const float* crystal_pitch_Z,</span>
<span class="s2">                const float distance_between_array_pixel, int number_of_events, const int begin_event_gpu_limitation,</span>
<span class="s2">                const int end_event_gpu_limitation, const float* a, const float* a_normal, const float* a_cf, const float* b,</span>
<span class="s2">                const float* b_normal, const float* b_cf, const float* c, const float* c_normal, const float* c_cf, const float* d, const float* d_normal,</span>
<span class="s2">                const float* d_cf, const short* A, const short* B, const short* C, float* adjust_coef, float* sum_vor,</span>
<span class="s2">                char* fov_cut_matrix, float* time_factor, float* m_values, float* m_values_at,</span>
<span class="s2">                float* b_values, float* b_values_at, float* max_D, float* inflex_points_x, float* linear_attenuation_A,</span>
<span class="s2">                float* linear_attenuation_B)</span>
<span class="s2">                       {</span>
<span class="s2">                       extern __shared__ float adjust_coef_shared[];</span>
<span class="s2">                       int idt = blockIdx.x * blockDim.x + threadIdx.x;</span>


<span class="s2">                       float d2;</span>
<span class="s2">                       float d2_normal;</span>
<span class="s2">                       float d2_cf;</span>
<span class="s2">                       float normal_value;</span>
<span class="s2">                       float value;</span>
<span class="s2">                       float value_cf;</span>
<span class="s2">                       short a_temp;</span>
<span class="s2">                       short b_temp;</span>
<span class="s2">                       short c_temp;</span>
<span class="s2">                       char fov_cut_temp;</span>
<span class="s2">                       int i_s = threadIdx.x;</span>
<span class="s2">                       float width;</span>
<span class="s2">                       float height;</span>
<span class="s2">                       float distance;</span>
<span class="s2">                       float distance_other;</span>
<span class="s2">                       float solid_angle;</span>
<span class="s2">                       float distance_crystal;</span>
<span class="s2">                       float distance_at;</span>
<span class="s2">                       float idrf;</span>

<span class="s2">                       if (idt &gt;= n * m * p)</span>
<span class="s2">                       {</span>
<span class="s2">                           return;</span>
<span class="s2">                       }</span>

<span class="s2">                       __syncthreads();</span>
<span class="s2">                       adjust_coef_shared[i_s] = adjust_coef[idt];</span>
<span class="s2">                       a_temp = A[idt];</span>
<span class="s2">                       b_temp = B[idt];</span>
<span class="s2">                       c_temp = C[idt];</span>
<span class="s2">                       fov_cut_temp = fov_cut_matrix[idt];</span>



<span class="s2">                       for (int e = begin_event_gpu_limitation; e &lt; end_event_gpu_limitation; e++)</span>
<span class="s2">                       {</span>
<span class="s2">                           if (fov_cut_temp != 0)</span>
<span class="s2">                           {</span>
<span class="s2">                               normal_value = a_normal[e] * a_temp + b_normal[e] * b_temp + c_normal[e] * c_temp - d_normal[e];</span>
<span class="s2">                               d2_normal = crystal_pitch_XY[e] * sqrt(a_normal[e] * a_normal[e] + b_normal[e] * b_normal[e] + c_normal[e] * c_normal[e]);</span>

<span class="s2">                               if (normal_value &lt; d2_normal &amp;&amp; normal_value &gt;= -d2_normal)</span>
<span class="s2">                               {</span>
<span class="s2">                                   value = a[e] * a_temp + b[e] * b_temp + c[e] * c_temp - d[e];</span>
<span class="s2">                                   d2 = crystal_pitch_Z[e] * sqrt(a[e] * a[e] + b[e] * b[e] + c[e] * c[e]);</span>


<span class="s2">                                   if (value &lt; d2 &amp;&amp; value &gt;= -d2)</span>
<span class="s2">                                   {</span>
<span class="s2">                                       value_cf = a_cf[e] * a_temp + b_cf[e] * b_temp + c_cf[e] * c_temp - d_cf[e];</span>
<span class="s2">                                       d2_cf = distance_between_array_pixel * sqrt(a_cf[e] * a_cf[e] + b_cf[e] * b_cf[e] + c_cf[e] * c_cf[e]);</span>


<span class="s2">                                       if (value_cf &gt;= -d2_cf &amp;&amp; value_cf &lt; d2_cf)</span>
<span class="s2">                                       {</span>
<span class="s2">                                           if (sqrt(value * value + normal_value * normal_value + value_cf * value_cf) &lt;= sqrt(d2 * d2 + d2_normal * d2_normal + d2_cf * d2_cf))</span>
<span class="s2">                                           {</span>
<span class="s2">                                               width = 2 * (crystal_pitch_Z[e] - abs(value));</span>
<span class="s2">                                               height = 2 * (crystal_pitch_XY[e] - abs(normal_value));</span>
<span class="s2">                                               distance = d2_cf + abs(value_cf);</span>
<span class="s2">                                               distance_other = d2_cf - abs(value_cf);</span>
<span class="s2">                                               distance_at = m_values_at[e] * value + b_values_at[e];</span>

<span class="s2">                                               if (value &lt;= inflex_points_x[2 * e])</span>
<span class="s2">                                               {</span>
<span class="s2">                                                   distance_crystal = m_values[2 * e] * value + b_values[2 * e];</span>
<span class="s2">                                                   distance_at = 0;</span>
<span class="s2">                                               }</span>
<span class="s2">                                               else if (value &gt; inflex_points_x[2 * e + 1])</span>
<span class="s2">                                               {</span>
<span class="s2">                                                   distance_crystal = m_values[2 * e + 1] * value + b_values[2 * e + 1];</span>
<span class="s2">                                               }</span>

<span class="s2">                                               else</span>
<span class="s2">                                               {</span>
<span class="s2">                                                   distance_crystal = max_D[e];</span>


<span class="s2">                                               }</span>
<span class="s2">                                              </span>
<span class="s2">                                               idrf = (1 - exp(-linear_attenuation_A[e] * distance_crystal)) * exp(-linear_attenuation_A[e] * distance_at);</span>

<span class="s2">                                               if (idrf &lt; 0)</span>
<span class="s2">                                               {</span>
<span class="s2">                                                   idrf = 0;</span>
<span class="s2">                                               }</span>
<span class="s2">                                               solid_angle = 4 * width * height / (2 * distance * sqrt(4 * distance * distance + width * width + height * height));</span>

<span class="s2">                                                if (sum_vor[e]!=0)</span>
<span class="s2">                                                {</span>
<span class="s2">                                               adjust_coef_shared[i_s] += idrf / sum_vor[e];</span>
<span class="s2">                                                 }</span>


<span class="s2">                                               /*</span>
<span class="s2">                                               (4 * asin(sin(tan(width/distance))*sin(tan(height/distance))))*(4 * asin(sin(tan(width/distance))*sin(tan(height/distance))))/sum_vor[e];</span>
<span class="s2">                                           adjust_coef_shared[i_s] += time_factor[e]*(1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[e]);</span>

<span class="s2">                                               */</span>
<span class="s2">                                           }</span>

<span class="s2">                                       }</span>

<span class="s2">                                       /*</span>
<span class="s2">                                       (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/</span>
<span class="s2">                                       normal_value= a_normal[e]*a_temp+b_normal[e]*b_temp+c_normal[e] * c_temp-d_normal[e];</span>
<span class="s2">                        d2_normal = error_pixel+crystal_pitch_XY * sqrt(a_normal[e]*a_normal[e]+b_normal[e]*b_normal[e]+c_normal[e]*c_normal[e]);</span>
<span class="s2">                                      adjust_coef_shared[i_s] += /(sum_vor[e]*time_factor[e]);</span>
<span class="s2">                                     adjust_coef_shared[i_s] += (1-(sqrt(value*value+normal_value*normal_value+value_cf*value_cf))/sqrt(d2*d2+d2_normal*d2_normal+d2_cf*d2_cf))/(sum_vor[0]*time_factor[e]);</span>
<span class="s2">                                        */</span>





<span class="s2">                                   }</span>
<span class="s2">                               }</span>

<span class="s2">                           }</span>

<span class="s2">                       }</span>

<span class="s2">                       adjust_coef[idt] = adjust_coef_shared[i_s];</span>
<span class="s2">                       __syncthreads();</span>
<span class="s2">}</span>
<span class="s2">                             &quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># float crystal_pitch, int number_of_events, float *a, float *b, float *c, float *d, int *A, int *B, int *C, float *im, float *vector_matrix</span>
        <span class="c1"># Host Code   B, C, im, vector_matrix,</span>
        <span class="n">number_of_datasets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Number of datasets (and concurrent operations) used.</span>
        <span class="n">number_of_datasets_back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Number of datasets (and concurrent operations) used.</span>
        <span class="c1"># Start concurrency Test</span>
        <span class="c1"># Event as reference point</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">ref</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>

        <span class="c1"># Create the streams and events needed to calculation</span>
        <span class="n">stream</span><span class="p">,</span> <span class="n">event</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">marker_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;kernel_begin&#39;</span><span class="p">,</span> <span class="s1">&#39;kernel_end&#39;</span><span class="p">]</span>
        <span class="c1"># Create List to allocate chunks of data</span>
        <span class="n">A_cut_gpu</span><span class="p">,</span> <span class="n">B_cut_gpu</span><span class="p">,</span> <span class="n">C_cut_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">A_cut</span><span class="p">,</span> <span class="n">B_cut</span><span class="p">,</span> <span class="n">C_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_gpu</span><span class="p">,</span> <span class="n">b_gpu</span><span class="p">,</span> <span class="n">c_gpu</span><span class="p">,</span> <span class="n">d_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">a_normal_gpu</span><span class="p">,</span> <span class="n">b_normal_gpu</span><span class="p">,</span> <span class="n">c_normal_gpu</span><span class="p">,</span> <span class="n">d_normal_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_cut</span><span class="p">,</span> <span class="n">b_cut</span><span class="p">,</span> <span class="n">c_cut</span><span class="p">,</span> <span class="n">d_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_normal_cut</span><span class="p">,</span> <span class="n">b_normal_cut</span><span class="p">,</span> <span class="n">c_normal_cut</span><span class="p">,</span> <span class="n">d_normal_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_cf_cut</span><span class="p">,</span> <span class="n">b_cf_cut</span><span class="p">,</span> <span class="n">c_cf_cut</span><span class="p">,</span> <span class="n">d_cf_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_cut_gpu</span><span class="p">,</span> <span class="n">b_cut_gpu</span><span class="p">,</span> <span class="n">c_cut_gpu</span><span class="p">,</span> <span class="n">d_cut_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_cut_normal_gpu</span><span class="p">,</span> <span class="n">b_cut_normal_gpu</span><span class="p">,</span> <span class="n">c_cut_normal_gpu</span><span class="p">,</span> <span class="n">d_cut_normal_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">a_cf_cut_gpu</span><span class="p">,</span> <span class="n">b_cf_cut_gpu</span><span class="p">,</span> <span class="n">c_cf_cut_gpu</span><span class="p">,</span> <span class="n">d_cf_cut_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">time_factor_cut_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">sum_vor_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">sum_vor_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">adjust_coef_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">adjust_coef_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">adjust_coef_pinned</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets_back</span>
        <span class="n">fov_cut_matrix_cutted_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets_back</span>
        <span class="n">fov_cut_matrix_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="c1"># fov_cut_matrix_gpu = [None] * number_of_datasets</span>
        <span class="n">sum_vor_pinned</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">distance_to_center_plane_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">distance_to_center_plane_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">distance_to_center_plane_normal_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">distance_to_center_plane_normal_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">plane_centerA1_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerA1_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerB1_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerB1_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerC1_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerC1_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>

        <span class="n">plane_centerA1_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerB1_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>
        <span class="n">plane_centerC1_gpu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)</span>

        <span class="n">m_values_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">m_values_at_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">b_values_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">b_values_at_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">max_D_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">inflex_points_x_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">linear_attenuation_crystal_A_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">linear_attenuation_crystal_B_listMode_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">m_values_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">b_values_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">m_values_at_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">b_values_at_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">max_D_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">inflex_points_x_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">linear_attenuation_A_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
        <span class="n">linear_attenuation_B_gpu_cut</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

        <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_of_events</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">intersection_points_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">intersection_points</span><span class="o">.</span><span class="n">size</span>
                                                 <span class="o">*</span> <span class="n">intersection_points</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">intersection_points_gpu</span><span class="p">,</span> <span class="n">intersection_points</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">)):</span>
            <span class="n">plane_centerA1_cut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
            <span class="n">plane_centerA1_gpu_cut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
            <span class="n">plane_centerB1_cut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
            <span class="n">plane_centerB1_gpu_cut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
            <span class="n">plane_centerC1_cut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>
            <span class="n">plane_centerC1_gpu_cut</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">number_of_datasets</span>

            <span class="n">plane_centerA1_gpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                                                   <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">plane_centerB1_gpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerB1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                                                   <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerB1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">plane_centerC1_gpu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerC1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                                                   <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerC1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">plane_centerA1_gpu</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerA1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">plane_centerB1_gpu</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerB1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">plane_centerC1_gpu</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">crystal_central_planes</span><span class="o">.</span><span class="n">plane_centerC1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Streams and Events creation</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets</span><span class="p">):</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">())</span>
            <span class="n">event</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">marker_names</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">())</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">marker_names</span><span class="p">))]))</span>

        <span class="c1"># Foward Projection Memory Allocation</span>
        <span class="c1"># Variables that need an unique alocation</span>
        <span class="c1"># A_shappened = np.ascontiguousarray(A.reshape(A.shape[0]*A.shape[1]*A.shape[2]), dtype=np.int32)</span>
        <span class="c1"># B_shappened = np.ascontiguousarray(B.reshape(B.shape[0]*B.shape[1]*B.shape[2]), dtype=np.int32)</span>
        <span class="c1"># C_shappened = np.ascontiguousarray(C.reshape(C.shape[0]*C.shape[1]*C.shape[2]), dtype=np.int32)</span>
        <span class="n">im_shappened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">fov_cut_matrix_shappened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="n">fov_cut_matrix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fov_cut_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">fov_cut_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">fov_cut_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span>

        <span class="c1"># forward_projection_arrays_page_locked_memory_allocations = [A_gpu, B_gpu, C_gpu, im_gpu]</span>

        <span class="c1"># A_gpu = cuda.mem_alloc(A_shappened.size * A_shappened.dtype.itemsize)</span>
        <span class="c1"># B_gpu = cuda.mem_alloc(B_shappened.size * B_shappened.dtype.itemsize)</span>
        <span class="c1"># C_gpu = cuda.mem_alloc(C_shappened.size * C_shappened.dtype.itemsize)</span>
        <span class="n">im_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">im_shappened</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">im_shappened</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">fov_cut_matrix_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">fov_cut_matrix_shappened</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">fov_cut_matrix_shappened</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="c1"># texref = mod_forward_projection_shared_mem.get_texref(&#39;tex&#39;)</span>
        <span class="c1"># texref.set_address(fov_cut_matrix_gpu, fov_cut_matrix_shappened.size * fov_cut_matrix_shappened.dtype.itemsize)</span>
        <span class="c1"># # texref.set_format(cuda.array_format.UNSIGNED_INT8, 1)</span>

        <span class="c1"># cuda.memcpy_htod_async(A_gpu, A_shappened)</span>
        <span class="c1"># cuda.memcpy_htod_async(B_gpu, B_shappened)</span>
        <span class="c1"># cuda.memcpy_htod_async(C_gpu, C_shappened)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">im_gpu</span><span class="p">,</span> <span class="n">im_shappened</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">fov_cut_matrix_gpu</span><span class="p">,</span> <span class="n">fov_cut_matrix_shappened</span><span class="p">)</span>

        <span class="n">a_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">b_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">c_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">d_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">a_normal_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">a_normal</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">a_normal</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">b_normal_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">b_normal</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_normal</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">c_normal_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">c_normal</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">c_normal</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">d_normal_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">d_normal</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">d_normal</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">a_cf_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">a_cf</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">a_cf</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">b_cf_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">b_cf</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_cf</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">c_cf_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">c_cf</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">c_cf</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">d_cf_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">d_cf</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">d_cf</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">sum_vor_t_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">sum_vor</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">sum_vor</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">distance_to_center_plane_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">distance_to_center_plane_normal_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">time_factor_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">time_factor</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">time_factor</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="c1"># Transfer memory to Optimizer</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">a_gpu</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_gpu</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">c_gpu</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">d_gpu</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">a_normal_gpu</span><span class="p">,</span> <span class="n">a_normal</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_normal_gpu</span><span class="p">,</span> <span class="n">b_normal</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">c_normal_gpu</span><span class="p">,</span> <span class="n">c_normal</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">d_normal_gpu</span><span class="p">,</span> <span class="n">d_normal</span><span class="p">)</span>

        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">a_cf_gpu</span><span class="p">,</span> <span class="n">a_cf</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_cf_gpu</span><span class="p">,</span> <span class="n">b_cf</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">c_cf_gpu</span><span class="p">,</span> <span class="n">c_cf</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">d_cf_gpu</span><span class="p">,</span> <span class="n">d_cf</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">time_factor_gpu</span><span class="p">,</span> <span class="n">time_factor</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">distance_to_center_plane_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">distance_to_center_plane_normal_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span><span class="p">)</span>

        <span class="n">m_values_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">b_values_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">m_values_at_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_at_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_at_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">b_values_at_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_at_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_at_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">max_D_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">max_D_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">max_D_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">inflex_points_x_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">inflex_points_x_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">inflex_points_x_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">linear_attenuation_A_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_A_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_A_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="n">linear_attenuation_B_gpu</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_B_listMode</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_B_listMode</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">m_values_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_values_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">m_values_at_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_at_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_values_at_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_at_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">max_D_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">max_D_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">inflex_points_x_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">inflex_points_x_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">linear_attenuation_A_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_A_listMode</span><span class="p">)</span>
        <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">linear_attenuation_B_gpu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_B_listMode</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets</span><span class="p">):</span>
            <span class="c1"># if dataset == number_of_datasets:</span>
            <span class="c1">#     begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
            <span class="c1">#     end_dataset = number_of_events</span>
            <span class="c1">#     adjust_coef_cut[dataset] = np.ascontiguousarray(</span>
            <span class="c1">#         adjust_coef[int(np.floor(im_cut_dim[0] * dataset)):adjust_coef.shape[0],</span>
            <span class="c1">#         int(np.floor(im_cut_dim[1] * dataset)):adjust_coef.shape[1],</span>
            <span class="c1">#         int(np.floor(im_cut_dim[2] * dataset)):adjust_coef.shape[2]],</span>
            <span class="c1">#         dtype=np.float32)</span>
            <span class="c1">#     fov_cut_matrix_cut[dataset] = np.ascontiguousarray(</span>
            <span class="c1">#         fov_cut_matrix[int(np.floor(im_cut_dim[0] * dataset)):fov_cut_matrix.shape[0],</span>
            <span class="c1">#         int(np.floor(im_cut_dim[1] * dataset)):fov_cut_matrix.shape[1],</span>
            <span class="c1">#         int(np.floor(im_cut_dim[2] * dataset)):fov_cut_matrix.shape[2]],</span>
            <span class="c1">#         dtype=np.float32)</span>
            <span class="c1"># else:</span>
            <span class="n">begin_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">number_of_events</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
            <span class="n">end_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">((</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">number_of_events</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>

            <span class="c1"># Cutting dataset</span>
            <span class="c1"># For forward projection the data is cutted by number of events. For backprojection is cutted per image pieces of image</span>
            <span class="n">a_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">b_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">c_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">d_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">a_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_normal</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">b_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_normal</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">c_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_normal</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">d_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_normal</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>

            <span class="n">a_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_cf</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">b_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">b_cf</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">c_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_cf</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">d_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_cf</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_vor</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">distance_to_center_plane_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
            <span class="n">distance_to_center_plane_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_center_plane_normal</span><span class="p">[</span>
                                                           <span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>

            <span class="c1"># Forward</span>
            <span class="n">a_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">a_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">a_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">b_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">b_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">c_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">c_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">c_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">d_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">d_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">d_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">a_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">a_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">a_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">b_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">b_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">c_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">c_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">c_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">d_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">d_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">d_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">a_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">a_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">a_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">b_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">b_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">c_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">c_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">c_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">d_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">d_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">d_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">distance_to_center_plane_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">distance_to_center_plane_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">distance_to_center_plane_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">distance_to_center_plane_normal_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">distance_to_center_plane_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">distance_to_center_plane_normal_cut</span><span class="p">[</span>
                    <span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">sum_vor_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">register_host_memory</span><span class="p">(</span><span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">==</span> <span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">sum_vor_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="c1"># sum_vor_gpu[dataset] = np.intp(x.base.get_device_pointer())</span>
            <span class="c1"># cuda.memcpy_htod_async(probability_gpu[dataset], probability_cut[dataset])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">a_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">a_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">c_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">c_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">d_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">d_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">a_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">a_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">c_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">c_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">d_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">d_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">a_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">a_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">c_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">c_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">d_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">d_cf_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">distance_to_center_plane_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">distance_to_center_plane_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">distance_to_center_plane_normal_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                   <span class="n">distance_to_center_plane_normal_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

            <span class="n">m_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">m_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">m_values_at_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">b_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">b_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">b_values_at_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">max_D_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">max_D_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">inflex_points_x_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">inflex_points_x_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">linear_attenuation_crystal_A_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_A_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>
            <span class="n">linear_attenuation_crystal_B_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">doi_mapping</span><span class="o">.</span><span class="n">linear_attenuation_crystal_B_listMode</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">])</span>

            <span class="n">m_values_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">m_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">m_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">b_values_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">b_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">m_values_at_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">m_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">m_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">b_values_at_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">b_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">b_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">max_D_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">max_D_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">max_D_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">inflex_points_x_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">inflex_points_x_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">inflex_points_x_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">linear_attenuation_A_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">linear_attenuation_crystal_A_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">linear_attenuation_crystal_A_listMode_cut</span><span class="p">[</span>
                    <span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">linear_attenuation_B_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">linear_attenuation_crystal_B_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">linear_attenuation_crystal_B_listMode_cut</span><span class="p">[</span>
                    <span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">m_values_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">m_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_values_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_values_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">m_values_at_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">m_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">b_values_at_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_values_at_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">max_D_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">max_D_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">inflex_points_x_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">inflex_points_x_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">linear_attenuation_A_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                   <span class="n">linear_attenuation_crystal_A_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">linear_attenuation_B_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                   <span class="n">linear_attenuation_crystal_B_listMode_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

        <span class="n">adjust_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">adjust_coef</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">adjust_coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">adjust_coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">adjust_coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># fov_cut_matrix = np.ascontiguousarray(fov_cut_matrix.reshape(</span>
        <span class="c1">#     fov_cut_matrix.shape[0] * fov_cut_matrix.shape[1] * fov_cut_matrix.shape[2]),</span>
        <span class="c1">#     dtype=np.float32)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">short</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">short</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">short</span><span class="p">)</span>

        <span class="c1"># ---- Divide into datasets variables backprojection</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets_back</span><span class="p">):</span>
            <span class="n">voxels_division</span> <span class="o">=</span> <span class="n">adjust_coef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">number_of_datasets_back</span>
            <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                <span class="n">adjust_coef</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="n">fov_cut_matrix_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                <span class="n">fov_cut_matrix_shappened</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span>

            <span class="n">A_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                <span class="n">A</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">short</span><span class="p">)</span>

            <span class="n">B_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                <span class="n">B</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">short</span><span class="p">)</span>

            <span class="n">C_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                <span class="n">C</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">short</span><span class="p">)</span>
            <span class="c1"># Backprojection</span>
            <span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">adjust_coef_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">register_host_memory</span><span class="p">(</span><span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">adjust_coef_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">==</span> <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">adjust_coef_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

            <span class="n">fov_cut_matrix_cutted_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">fov_cut_matrix_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">fov_cut_matrix_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">A_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">A_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">A_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">B_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">B_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">B_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">C_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span>
                <span class="n">C_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">C_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">fov_cut_matrix_cutted_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">fov_cut_matrix_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">A_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">A_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">B_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">B_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
            <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">C_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">C_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

        <span class="n">free</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">mem_get_info</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.1f</span><span class="s1"> </span><span class="si">%%</span><span class="s1"> of device memory is free.&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">free</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">total</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>

        <span class="c1"># -------------OSEM---------</span>
        <span class="n">it</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_iterations</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_subsets</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number events for reconstruction: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number_of_events</span><span class="p">))</span>

        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Iteration number: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">----------------&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">begin_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">end_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">number_of_events</span> <span class="o">/</span> <span class="n">subsets</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subsets</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Subset number: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span>
                <span class="n">number_of_events_subset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">end_event</span> <span class="o">-</span> <span class="n">begin_event</span><span class="p">)</span>
                <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Cycle forward Projection</span>
                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">dataset</span> <span class="o">==</span> <span class="n">number_of_datasets</span><span class="p">:</span>
                        <span class="n">begin_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">number_of_events_subset</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
                        <span class="n">end_dataset</span> <span class="o">=</span> <span class="n">number_of_events_subset</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">begin_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">number_of_events_subset</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
                        <span class="n">end_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">((</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">number_of_events_subset</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>

                    <span class="n">threadsperblock</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">blockspergrid_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(((</span><span class="n">end_dataset</span> <span class="o">-</span> <span class="n">begin_dataset</span><span class="p">))</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">blockspergrid_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">blockspergrid_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">blockspergrid</span> <span class="o">=</span> <span class="p">(</span><span class="n">blockspergrid_x</span><span class="p">,</span> <span class="n">blockspergrid_y</span><span class="p">,</span> <span class="n">blockspergrid_z</span><span class="p">)</span>
                    <span class="n">event</span><span class="p">[</span><span class="n">dataset</span><span class="p">][</span><span class="s1">&#39;kernel_begin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="c1"># depth = np.int32(5)</span>
                    <span class="c1"># weight = np.int32(A.shape[2]/2)</span>
                    <span class="c1"># height = np.int32(A.shape[2]/2)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdrf</span><span class="p">:</span>
                        <span class="n">func_forward</span> <span class="o">=</span> <span class="n">mod_forward_projection_shared_mem_cdrf</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;forward_projection_cdrf&quot;</span><span class="p">)</span>
                        <span class="n">func_forward</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">start_x</span><span class="p">,</span> <span class="n">start_y</span><span class="p">,</span> <span class="n">start_z</span><span class="p">,</span>
                                     <span class="n">distance_to_center_plane_normal_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">distance_to_center_plane_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">half_distance_between_array_pixel</span><span class="p">,</span>
                                     <span class="n">number_of_events</span><span class="p">,</span> <span class="n">begin_dataset</span><span class="p">,</span> <span class="n">end_dataset</span><span class="p">,</span> <span class="n">a_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">a_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">a_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">b_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">c_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">c_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">c_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">d_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">d_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">d_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">sum_vor_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">fov_cut_matrix_gpu</span><span class="p">,</span> <span class="n">im_gpu</span><span class="p">,</span> <span class="n">m_values_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">b_values_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">m_values_at_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">b_values_at_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">max_D_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">inflex_points_x_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">linear_attenuation_A_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">linear_attenuation_B_gpu_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">block</span><span class="o">=</span><span class="n">threadsperblock</span><span class="p">,</span>
                                     <span class="n">grid</span><span class="o">=</span><span class="n">blockspergrid</span><span class="p">,</span>
                                     <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">func_forward</span> <span class="o">=</span> <span class="n">mod_forward_projection_shared_mem</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;forward_projection&quot;</span><span class="p">)</span>
                        <span class="n">func_forward</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">start_x</span><span class="p">,</span> <span class="n">start_y</span><span class="p">,</span> <span class="n">start_z</span><span class="p">,</span> <span class="n">half_crystal_pitch_xy</span><span class="p">,</span>
                                     <span class="n">half_crystal_pitch_z</span><span class="p">,</span>
                                     <span class="n">half_distance_between_array_pixel</span><span class="p">,</span>
                                     <span class="n">number_of_events</span><span class="p">,</span> <span class="n">begin_dataset</span><span class="p">,</span> <span class="n">end_dataset</span><span class="p">,</span> <span class="n">a_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">a_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">a_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">b_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">b_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">c_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">c_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">c_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">d_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">d_cut_normal_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">d_cf_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                     <span class="n">sum_vor_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">fov_cut_matrix_gpu</span><span class="p">,</span> <span class="n">im_gpu</span><span class="p">,</span>
                                     <span class="n">block</span><span class="o">=</span><span class="n">threadsperblock</span><span class="p">,</span>
                                     <span class="n">grid</span><span class="o">=</span><span class="n">blockspergrid</span><span class="p">,</span>
                                     <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

                <span class="c1"># Sincronization of streams</span>
                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets</span><span class="p">):</span>  <span class="c1"># Commenting out this line should break concurrency.</span>
                    <span class="n">event</span><span class="p">[</span><span class="n">dataset</span><span class="p">][</span><span class="s1">&#39;kernel_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

                <span class="c1"># Transfering data from Optimizer</span>
                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets</span><span class="p">):</span>
                    <span class="n">begin_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">number_of_events</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
                    <span class="n">end_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">((</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">number_of_events</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
                    <span class="c1"># cuda.memcpy_dtoh_async(sum_vor[begin_dataset:end_dataset], sum_vor_gpu[dataset])</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh_async</span><span class="p">(</span><span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">sum_vor_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="c1"># cuda.cudaStream.Synchronize(stream[dataset])</span>

                    <span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                <span class="n">cuda</span><span class="o">.</span><span class="n">Context</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Time part Forward Projection </span><span class="si">{}</span><span class="s1"> : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">))</span>
                <span class="c1"># number_of_datasets = np.int32(2)</span>
                <span class="n">teste</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sum_vor</span><span class="p">)</span>
                <span class="c1"># sum_vor[sum_vor&lt;1]=0</span>
                <span class="n">sum_vor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">teste</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># sum_vor=np.ascontiguousarray(np.ones((self.a.shape)), dtype=np.float32)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SUM VOR: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">teste</span><span class="p">)))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SUM VOR: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">teste</span><span class="p">))</span>
                <span class="c1"># cuda.memcpy_htod_async(sum_vor_t_gpu, sum_vor)</span>

                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">sum_vor_t_gpu</span><span class="p">,</span> <span class="n">sum_vor</span><span class="p">)</span>

                <span class="c1"># ------------BACKPROJECTION-----------</span>

                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets_back</span><span class="p">):</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
                    <span class="n">begin_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">end_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">number_of_events_subset</span><span class="p">)</span>

                    <span class="c1"># begin_dataset = np.int32(0)</span>
                    <span class="c1"># end_dataset = np.int32(number_of_events)</span>

                    <span class="n">event</span><span class="p">[</span><span class="n">dataset</span><span class="p">][</span><span class="s1">&#39;kernel_begin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="c1"># weight_cutted, height_cutted, depth_cutted = np.int32(adjust_coef_cut[dataset].shape[0]), np.int32(</span>
                    <span class="c1">#     adjust_coef_cut[dataset].shape[1]), np.int32(adjust_coef_cut[dataset].shape[2])</span>
                    <span class="n">weight_cutted</span><span class="p">,</span> <span class="n">height_cutted</span><span class="p">,</span> <span class="n">depth_cutted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span>
                        <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">number_of_voxels_thread</span> <span class="o">=</span> <span class="mi">64</span>
                    <span class="n">threadsperblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">number_of_voxels_thread</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">blockspergrid_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="n">blockspergrid_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="n">blockspergrid_z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="c1"># blockspergrid_y = int(math.ceil(adjust_coef_cut[dataset].shape[1] / threadsperblock[1]))</span>
                    <span class="c1"># blockspergrid_z = int(math.ceil(adjust_coef_cut[dataset].shape[2] / threadsperblock[2]))</span>
                    <span class="n">blockspergrid</span> <span class="o">=</span> <span class="p">(</span><span class="n">blockspergrid_x</span><span class="p">,</span> <span class="n">blockspergrid_y</span><span class="p">,</span> <span class="n">blockspergrid_z</span><span class="p">)</span>
                    <span class="n">shared_memory</span> <span class="o">=</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">threadsperblock</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cdrf</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_calculation_flag</span><span class="p">:</span>
                            <span class="n">func_backward</span> <span class="o">=</span> <span class="n">mod_normalization_shared_mem_cdrf</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;normalization_cdrf&quot;</span><span class="p">)</span>
                            <span class="n">func_backward</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">weight_cutted</span><span class="p">,</span> <span class="n">height_cutted</span><span class="p">,</span> <span class="n">depth_cutted</span><span class="p">,</span>
                                          <span class="n">distance_to_center_plane_normal_gpu</span><span class="p">,</span>
                                          <span class="n">distance_to_center_plane_gpu</span><span class="p">,</span> <span class="n">half_distance_between_array_pixel</span><span class="p">,</span>
                                          <span class="n">number_of_events</span><span class="p">,</span> <span class="n">begin_dataset</span><span class="p">,</span> <span class="n">end_dataset</span><span class="p">,</span> <span class="n">a_gpu</span><span class="p">,</span> <span class="n">a_normal_gpu</span><span class="p">,</span> <span class="n">a_cf_gpu</span><span class="p">,</span>
                                          <span class="n">b_gpu</span><span class="p">,</span> <span class="n">b_normal_gpu</span><span class="p">,</span> <span class="n">b_cf_gpu</span><span class="p">,</span> <span class="n">c_gpu</span><span class="p">,</span> <span class="n">c_normal_gpu</span><span class="p">,</span> <span class="n">c_cf_gpu</span><span class="p">,</span> <span class="n">d_gpu</span><span class="p">,</span>
                                          <span class="n">d_normal_gpu</span><span class="p">,</span> <span class="n">d_cf_gpu</span><span class="p">,</span> <span class="n">A_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">B_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="n">C_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="n">sum_vor_t_gpu</span><span class="p">,</span> <span class="n">fov_cut_matrix_cutted_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">time_factor_gpu</span><span class="p">,</span>
                                          <span class="n">plane_centerA1_gpu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plane_centerA1_gpu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plane_centerA1_gpu</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                          <span class="n">plane_centerA1_gpu</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                          <span class="n">plane_centerB1_gpu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plane_centerB1_gpu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plane_centerB1_gpu</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                          <span class="n">plane_centerB1_gpu</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                          <span class="n">plane_centerC1_gpu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plane_centerC1_gpu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">plane_centerC1_gpu</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                          <span class="n">plane_centerC1_gpu</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">intersection_points_gpu</span><span class="p">,</span> <span class="n">m_values_gpu</span><span class="p">,</span> <span class="n">m_values_at_gpu</span><span class="p">,</span>
                                          <span class="n">b_values_gpu</span><span class="p">,</span> <span class="n">b_values_at_gpu</span><span class="p">,</span>
                                          <span class="n">max_D_gpu</span><span class="p">,</span> <span class="n">inflex_points_x_gpu</span><span class="p">,</span> <span class="n">linear_attenuation_A_gpu</span><span class="p">,</span>
                                          <span class="n">linear_attenuation_B_gpu</span><span class="p">,</span>
                                          <span class="n">block</span><span class="o">=</span><span class="n">threadsperblock</span><span class="p">,</span>
                                          <span class="n">grid</span><span class="o">=</span><span class="n">blockspergrid</span><span class="p">,</span>
                                          <span class="n">shared</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">number_of_voxels_thread</span><span class="p">),</span>
                                          <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="p">)</span>


                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">func_backward</span> <span class="o">=</span> <span class="n">mod_backward_projection_shared_mem_cdrf</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;backprojection_cdrf&quot;</span><span class="p">)</span>
                            <span class="n">func_backward</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">weight_cutted</span><span class="p">,</span> <span class="n">height_cutted</span><span class="p">,</span> <span class="n">depth_cutted</span><span class="p">,</span>
                                          <span class="n">distance_to_center_plane_normal_gpu</span><span class="p">,</span>
                                          <span class="n">distance_to_center_plane_gpu</span><span class="p">,</span> <span class="n">half_distance_between_array_pixel</span><span class="p">,</span>
                                          <span class="n">number_of_events</span><span class="p">,</span> <span class="n">begin_dataset</span><span class="p">,</span> <span class="n">end_dataset</span><span class="p">,</span> <span class="n">a_gpu</span><span class="p">,</span> <span class="n">a_normal_gpu</span><span class="p">,</span> <span class="n">a_cf_gpu</span><span class="p">,</span>
                                          <span class="n">b_gpu</span><span class="p">,</span> <span class="n">b_normal_gpu</span><span class="p">,</span> <span class="n">b_cf_gpu</span><span class="p">,</span> <span class="n">c_gpu</span><span class="p">,</span> <span class="n">c_normal_gpu</span><span class="p">,</span> <span class="n">c_cf_gpu</span><span class="p">,</span> <span class="n">d_gpu</span><span class="p">,</span>
                                          <span class="n">d_normal_gpu</span><span class="p">,</span> <span class="n">d_cf_gpu</span><span class="p">,</span> <span class="n">A_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">B_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="n">C_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="n">sum_vor_t_gpu</span><span class="p">,</span> <span class="n">fov_cut_matrix_cutted_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">time_factor_gpu</span><span class="p">,</span>
                                          <span class="n">m_values_gpu</span><span class="p">,</span> <span class="n">m_values_at_gpu</span><span class="p">,</span>
                                          <span class="n">b_values_gpu</span><span class="p">,</span> <span class="n">b_values_at_gpu</span><span class="p">,</span>
                                          <span class="n">max_D_gpu</span><span class="p">,</span> <span class="n">inflex_points_x_gpu</span><span class="p">,</span> <span class="n">linear_attenuation_A_gpu</span><span class="p">,</span>
                                          <span class="n">linear_attenuation_B_gpu</span><span class="p">,</span>
                                          <span class="n">block</span><span class="o">=</span><span class="n">threadsperblock</span><span class="p">,</span>
                                          <span class="n">grid</span><span class="o">=</span><span class="n">blockspergrid</span><span class="p">,</span>
                                          <span class="n">shared</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">number_of_voxels_thread</span><span class="p">),</span>
                                          <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                          <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_calculation_flag</span><span class="p">:</span>
                            <span class="n">func_backward</span> <span class="o">=</span> <span class="n">mod_normalization_shared_mem</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;normalization&quot;</span><span class="p">)</span>


                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">func_backward</span> <span class="o">=</span> <span class="n">mod_backward_projection_shared_mem</span><span class="o">.</span><span class="n">get_function</span><span class="p">(</span><span class="s2">&quot;backprojection&quot;</span><span class="p">)</span>

                        <span class="n">func_backward</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">weight_cutted</span><span class="p">,</span> <span class="n">height_cutted</span><span class="p">,</span> <span class="n">depth_cutted</span><span class="p">,</span> <span class="n">half_crystal_pitch_xy</span><span class="p">,</span>
                                      <span class="n">half_crystal_pitch_z</span><span class="p">,</span> <span class="n">half_distance_between_array_pixel</span><span class="p">,</span>
                                      <span class="n">number_of_events</span><span class="p">,</span> <span class="n">begin_dataset</span><span class="p">,</span> <span class="n">end_dataset</span><span class="p">,</span> <span class="n">a_gpu</span><span class="p">,</span> <span class="n">a_normal_gpu</span><span class="p">,</span> <span class="n">a_cf_gpu</span><span class="p">,</span>
                                      <span class="n">b_gpu</span><span class="p">,</span> <span class="n">b_normal_gpu</span><span class="p">,</span> <span class="n">b_cf_gpu</span><span class="p">,</span> <span class="n">c_gpu</span><span class="p">,</span> <span class="n">c_normal_gpu</span><span class="p">,</span> <span class="n">c_cf_gpu</span><span class="p">,</span> <span class="n">d_gpu</span><span class="p">,</span>
                                      <span class="n">d_normal_gpu</span><span class="p">,</span> <span class="n">d_cf_gpu</span><span class="p">,</span> <span class="n">A_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">B_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                      <span class="n">C_cut_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                      <span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                      <span class="n">sum_vor_t_gpu</span><span class="p">,</span> <span class="n">fov_cut_matrix_cutted_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">time_factor_gpu</span><span class="p">,</span>
                                      <span class="n">block</span><span class="o">=</span><span class="n">threadsperblock</span><span class="p">,</span>
                                      <span class="n">grid</span><span class="o">=</span><span class="n">blockspergrid</span><span class="p">,</span>
                                      <span class="n">shared</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">number_of_voxels_thread</span><span class="p">),</span>
                                      <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                      <span class="p">)</span>

                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets_back</span><span class="p">):</span>  <span class="c1"># Commenting out this line should break concurrency.</span>
                    <span class="n">event</span><span class="p">[</span><span class="n">dataset</span><span class="p">][</span><span class="s1">&#39;kernel_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets_back</span><span class="p">):</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_dtoh_async</span><span class="p">(</span><span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="n">adjust_coef</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span>

                <span class="n">cuda</span><span class="o">.</span><span class="n">Context</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Time part Backward Projection </span><span class="si">{}</span><span class="s1"> : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">toc</span><span class="p">))</span>

                <span class="c1"># Image Normalization</span>
                <span class="c1"># if i ==0:</span>
                <span class="c1">#     norm_im=np.copy(adjust_coef)</span>
                <span class="c1">#     norm_im=norm_im/np.max(norm_im)</span>
                <span class="c1">#     norm_im[norm_im == 0] = np.min(norm_im[np.nonzero(norm_im)])</span>
                <span class="c1"># normalization_matrix = gaussian_filter(normalization_matrix, 0.5)</span>

                <span class="c1"># im_med = np.load(&quot;C:\\Users\\pedro.encarnacao\\OneDrive - Universidade de Aveiro\\PhD\\Reconstruo\\NAF+FDG\\Easypet Scan 05 Aug 2019 - 14h 36m 33s\\static_image\\Easypet Scan 05 Aug 2019 - 14h 36m 33s mlem.npy&quot;)</span>
                <span class="c1"># self.algorithm = &quot;LM-MRP&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;LM-MRP&quot;</span><span class="p">:</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">kernel_filter_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">im_to_filter</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
                    <span class="n">im_med</span> <span class="o">=</span> <span class="n">median_filter</span><span class="p">(</span><span class="n">im_to_filter</span><span class="p">,</span> <span class="n">kernel_filter_size</span><span class="p">)</span>
                    <span class="n">penalized_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im_to_filter</span><span class="p">)</span>
                    <span class="n">penalized_term</span><span class="p">[</span><span class="n">im_med</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">im_to_filter</span><span class="p">[</span><span class="n">im_med</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">im_med</span><span class="p">[</span><span class="n">im_med</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">im_med</span><span class="p">[</span>
                        <span class="n">im_med</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">penalized_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">penalized_term</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">depth</span><span class="p">),</span>
                                                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="c1"># penalized_term = np.ascontiguousarray(penalized_term, dtype=np.float32)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;MAP&quot;</span><span class="p">:</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span>
                    <span class="n">im_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                        <span class="s2">&quot;C:</span><span class="se">\\</span><span class="s2">Users</span><span class="se">\\</span><span class="s2">pedro.encarnacao</span><span class="se">\\</span><span class="s2">OneDrive - Universidade de Aveiro</span><span class="se">\\</span><span class="s2">PhD</span><span class="se">\\</span><span class="s2">Reconstruo</span><span class="se">\\</span><span class="s2">NAF+FDG</span><span class="se">\\</span><span class="s2">Easypet Scan 05 Aug 2019 - 14h 36m 33s</span><span class="se">\\</span><span class="s2">static_image</span><span class="se">\\</span><span class="s2">Easypet Scan 05 Aug 2019 - 14h 36m 33s mlem.npy&quot;</span><span class="p">)</span>

                <span class="n">im</span><span class="p">[</span><span class="n">normalization_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">normalization_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">adjust_coef</span><span class="p">[</span>
                    <span class="n">normalization_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">normalization_matrix</span><span class="p">[</span><span class="n">normalization_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">im</span><span class="p">[</span><span class="n">normalization_matrix</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">==</span> <span class="s2">&quot;LM-MRP&quot;</span><span class="p">:</span>
                    <span class="n">im</span><span class="p">[</span><span class="n">penalized_term</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span><span class="p">[</span><span class="n">penalized_term</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">penalized_term</span><span class="p">[</span><span class="n">penalized_term</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
                <span class="c1"># im = fourier_gaussian(im, sigma=0.2)</span>
                <span class="c1"># im = gaussian_filter(im, 0.4)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SUM IMAGE: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im</span><span class="p">)))</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="c1"># im = im * adjust_coef / sensivity_matrix[np.nonzero(sensivity_matrix)]</span>
                <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">im_gpu</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>

                <span class="c1"># Clearing variables</span>
                <span class="n">sum_vor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

                <span class="n">adjust_coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_pixels_z</span><span class="p">),</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets</span><span class="p">):</span>
                    <span class="c1"># if dataset == number_of_datasets:</span>
                    <span class="c1">#     begin_dataset = np.int32(dataset * number_of_events / number_of_datasets)</span>
                    <span class="c1">#     end_dataset = number_of_events</span>
                    <span class="c1">#</span>
                    <span class="c1"># else:</span>
                    <span class="n">begin_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">number_of_events</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
                    <span class="n">end_dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">((</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">number_of_events</span> <span class="o">/</span> <span class="n">number_of_datasets</span><span class="p">)</span>
                    <span class="c1"># adjust_coef_cut[dataset] = np.ascontiguousarray(adjust_coef[:, :,</span>
                    <span class="c1">#                                                 int(np.floor(im_cut_dim[2] * dataset)):int(</span>
                    <span class="c1">#                                                     np.floor(im_cut_dim[2] * (dataset + 1)))],</span>
                    <span class="c1">#                                                 dtype=np.float32)</span>

                    <span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_vor</span><span class="p">[</span><span class="n">begin_dataset</span><span class="p">:</span><span class="n">end_dataset</span><span class="p">]</span>
                    <span class="c1"># cuda.memcpy_htod_async(sum_vor_gpu[dataset], sum_vor_cut[dataset])</span>
                    <span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">register_host_memory</span><span class="p">(</span><span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">==</span> <span class="n">sum_vor_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">sum_vor_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">sum_vor_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_datasets_back</span><span class="p">):</span>
                    <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjust_coef</span><span class="p">[</span><span class="n">dataset</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">:(</span><span class="n">dataset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">voxels_division</span><span class="p">]</span>
                    <span class="n">adjust_coef_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">=</span> <span class="n">cuda</span><span class="o">.</span><span class="n">register_host_memory</span><span class="p">(</span><span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">adjust_coef_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">]</span> <span class="o">==</span> <span class="n">adjust_coef_cut</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>
                    <span class="n">cuda</span><span class="o">.</span><span class="n">memcpy_htod_async</span><span class="p">(</span><span class="n">adjust_coef_gpu</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">adjust_coef_pinned</span><span class="p">[</span><span class="n">dataset</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="n">dataset</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">saved_image_by_iteration</span><span class="p">:</span>
                    <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_save_image_by_it</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sb</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signals_interface</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">signals_interface</span><span class="o">.</span><span class="n">trigger_update_label_reconstruction_status</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: Iteration </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_info_step</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">signals_interface</span><span class="o">.</span><span class="n">trigger_progress_reconstruction_partial</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sb</span> <span class="o">+</span> <span class="n">subsets</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">it</span> <span class="o">*</span> <span class="n">subsets</span><span class="p">),</span> <span class="mi">0</span><span class="p">)))</span>

        <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span> <span class="o">*</span> <span class="n">subsets</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_save_image_by_it</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">it</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sb</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">normalization</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;Normalization&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="s2">&quot;EasyPETScan_it</span><span class="si">{}</span><span class="s2">_sb</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="c1"># length = volume.shape[0] * volume.shape[2] * volume.shape[1]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">volume</span>
        <span class="n">shapeIm</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">output_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">arr</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span>
        <span class="n">output_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

        <span class="c1"># file_name = directory+&quot;/Acquisitions/SENS_0_5&quot;</span>
        <span class="c1"># file_name = directory+&quot;/Acquisitions/sens_0_25&quot;</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=c5ced968eda925caa686"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=c5ced968eda925caa686"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
       Copyright 2025, Pedro Encarnao.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.14.2.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>